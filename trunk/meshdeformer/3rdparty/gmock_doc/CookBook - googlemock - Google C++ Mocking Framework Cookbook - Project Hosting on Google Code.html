<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0049)http://code.google.com/p/googlemock/wiki/CookBook -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <LINK rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
 
 <SCRIPT type="text/javascript">
 
 (function(){function a(e){this.t={};this.tick=function(f,c,d){c=d?d:(new Date).getTime();this.t[f]=c};this.tick("start",null,e)}var b=new a;window.jstiming={Timer:a,load:b};try{var g=null;if(window.chrome&&window.chrome.csi)g=Math.floor(window.chrome.csi().pageT);if(g==null)if(window.gtbExternal)g=window.gtbExternal.pageT();if(g==null)if(window.external)g=window.external.pageT;if(g)window.jstiming.pt=g}catch(h){};})();

 
 
 
 var codesite_token = null;
 
 
 var logged_in_user_email = null;
 
 
 var relative_base_url = "";
 
 </SCRIPT>
 
 
 <TITLE>CookBook - 
 googlemock -
 
 Google C++ Mocking Framework Cookbook - Project Hosting on Google Code</TITLE>
 
 
 <LINK type="text/css" rel="stylesheet" href="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/ph_core.css">
 
 <LINK type="text/css" rel="stylesheet" href="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/ph_detail.css">
 
 
 
 <LINK type="application/atom+xml" rel="alternate" href="http://code.google.com/feeds/p/googlemock/svnchanges/basic?path=/wiki/CookBook.wiki">
 
 
<!--[if IE]>
 <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/6513215159156155175/css/d_ie.css" >
<![endif]-->
 <STYLE type="text/css">
 .menuIcon.off { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -42px }
 .menuIcon.on { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -28px }
 .menuIcon.down { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 0; }
 </STYLE>
<SCRIPT type="text/javascript" src="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/ga.js"></SCRIPT></HEAD><BODY class="t6">
 <SCRIPT type="text/javascript">
 var _gaq = _gaq || [];
 _gaq.push(
 ['siteTracker._setAccount', 'UA-18071-1'],
 ['siteTracker._trackPageview']);
 
 _gaq.push(
 ['projectTracker._setAccount', 'UA-4068653-1'],
 ['projectTracker._trackPageview']);
 
 (function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
 })();
 </SCRIPT>
 <DIV id="gaia">
 
 <SPAN>
 
 
 <A href="http://code.google.com/p/googlemock/wiki/CookBook#" id="projects-dropdown" onclick="return false;"><U>My favorites</U> <SMALL>â–¼</SMALL></A>
 
 | <A href="https://www.google.com/accounts/ServiceLogin?service=code&ltmpl=phosting&continue=http%3A%2F%2Fcode.google.com%2Fp%2Fgooglemock%2Fwiki%2FCookBook&followup=http%3A%2F%2Fcode.google.com%2Fp%2Fgooglemock%2Fwiki%2FCookBook" onclick="_CS_click(&#39;/gb/ph/signin&#39;);"><U>Sign in</U></A>
 
 </SPAN>

 </DIV>
 <DIV class="gbh" style="left: 0pt;"></DIV>
 <DIV class="gbh" style="right: 0pt;"></DIV>
 
 
 <DIV style="height: 1px"></DIV>
<!--[if IE 6]>
<div style="text-align:center;">
Support browsers that contribute to open source, try <a href="http://www.firefox.com">Firefox</a> or <a href="http://www.google.com/chrome">Google Chrome</a>.
</div>
<![endif]-->



 <TABLE style="padding:0px; margin: 20px 0px 0px 0px; width:100%" cellpadding="0" cellspacing="0">
 <TBODY><TR style="height: 58px;">
 
 <TD style="width: 55px; text-align:center;">
 <A href="http://code.google.com/p/googlemock/">
 
 
 
 <IMG src="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/logo" alt="Logo">
 
 
 </A>
 </TD>
 
 <TD style="padding-left: 0.5em">
 
 <DIV id="pname" style="margin: 0px 0px -3px 0px">
 <A href="http://code.google.com/p/googlemock/" style="text-decoration:none; color:#000">googlemock</A>
 
 </DIV>
 <DIV id="psum">
 <I><A id="project_summary_link" href="http://code.google.com/p/googlemock/" style="text-decoration:none; color:#000">Google C++ Mocking Framework</A></I>
 </DIV>
 
 </TD>
 <TD style="white-space:nowrap;text-align:right">
 <FORM action="http://code.google.com/hosting/search">
 <INPUT size="30" name="q" value="">
 <INPUT type="submit" name="projectsearch" value="Search projects">
 </FORM>
 </TD></TR>
 </TBODY></TABLE>


 
<TABLE id="mt" cellspacing="0" cellpadding="0" width="100%" border="0">
 <TBODY><TR>
 <TH onclick="if (!cancelBubble) _go(&#39;/p/googlemock/&#39;);">
 <DIV class="tab inactive">
 <DIV class="round4"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round1"></DIV>
 <DIV class="box-inner">
 <A onclick="cancelBubble=true;" href="http://code.google.com/p/googlemock/">Project&nbsp;Home</A>
 </DIV>
 </DIV>
 </TH><TD>&nbsp;&nbsp;</TD>
 
 
 
 
 <TH onclick="if (!cancelBubble) _go(&#39;/p/googlemock/downloads/list&#39;);">
 <DIV class="tab inactive">
 <DIV class="round4"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round1"></DIV>
 <DIV class="box-inner">
 <A onclick="cancelBubble=true;" href="http://code.google.com/p/googlemock/downloads/list">Downloads</A>
 </DIV>
 </DIV>
 </TH><TD>&nbsp;&nbsp;</TD>
 
 
 
 
 
 <TH onclick="if (!cancelBubble) _go(&#39;/p/googlemock/w/list&#39;);">
 <DIV class="tab active">
 <DIV class="round4"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round1"></DIV>
 <DIV class="box-inner">
 <A onclick="cancelBubble=true;" href="http://code.google.com/p/googlemock/w/list">Wiki</A>
 </DIV>
 </DIV>
 </TH><TD>&nbsp;&nbsp;</TD>
 
 
 
 
 
 <TH onclick="if (!cancelBubble) _go(&#39;/p/googlemock/issues/list&#39;);">
 <DIV class="tab inactive">
 <DIV class="round4"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round1"></DIV>
 <DIV class="box-inner">
 <A onclick="cancelBubble=true;" href="http://code.google.com/p/googlemock/issues/list">Issues</A>
 </DIV>
 </DIV>
 </TH><TD>&nbsp;&nbsp;</TD>
 
 
 
 
 
 <TH onclick="if (!cancelBubble) _go(&#39;/p/googlemock/source/checkout&#39;);">
 <DIV class="tab inactive">
 <DIV class="round4"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round1"></DIV>
 <DIV class="box-inner">
 <A onclick="cancelBubble=true;" href="http://code.google.com/p/googlemock/source/checkout">Source</A>
 </DIV>
 </DIV>
 </TH><TD>&nbsp;&nbsp;</TD>
 
 
 <TD width="100%">&nbsp;</TD>
 </TR>
</TBODY></TABLE>
<TABLE cellspacing="0" cellpadding="0" width="100%" align="center" border="0" class="st">
 <TBODY><TR>
 
 
 
 <TD>
 <DIV class="issueDetail">
<DIV class="isf">
 
 <SPAN class="inIssueList"> 
 <SPAN>Search</SPAN>
 <FORM action="http://code.google.com/p/googlemock/w/list" method="GET" style="display:inline">
 <SELECT id="can" name="can" style="font-size:92%">
 <OPTION disabled="disabled">Search within:</OPTION>
 
 <OPTION value="1">&nbsp;All wiki pages</OPTION>
 <OPTION value="3">&nbsp;Featured pages</OPTION>
 <OPTION value="2" selected="selected">&nbsp;Current pages</OPTION>
 
 
 <OPTION value="4">&nbsp;Deprecated pages</OPTION>
 
 </SELECT>
 <SPAN>for</SPAN>
 <SPAN id="qq"><INPUT type="text" size="38" id="q" name="q" value="" style="font-size:92%"></SPAN>
 
 
 <INPUT type="submit" value="Search" style="font-size:92%">
 </FORM>
 </SPAN>

 
 
 
 
 
 
 

</DIV>
</DIV>

 </TD>
 
 
 
 
 
 
 <TD height="4" align="right" valign="top" class="bevel-right">
 <DIV class="round4"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round1"></DIV>
 </TD>
 </TR>
</TBODY></TABLE>
<SCRIPT type="text/javascript">
 var cancelBubble = false;
 function _go(url) { document.location = url; }
</SCRIPT>


<DIV id="maincol">

 
<!-- IE -->







 <STYLE type="text/css">
 .artifactcomment {
 margin: .5em 0 0 0;
 padding: .3em 0 .3em .3em;
 border-top: 3px solid #c3d9ff;
 }
 #commentlist {
 border-bottom: 3px solid #c3d9ff;
 }
 #commentform { padding-top: 1em; }
 .delcom { background: #e8e8e8 }
 .commentcontent { margin: 1em 0;}
 </STYLE>


 <DIV id="wikicontent">
 <TABLE width="100%" border="0" cellspacing="0" cellpadding="0">
 <TBODY><TR>
 
 <TD class="vt" id="wikimaincol" width="100%">
 
 <DIV style="float:right; width:18em" id="wikimeta">
 <DIV class="pmeta_bubble_bg">
 <DIV class="round4"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round1"></DIV>
 <DIV class="box-inner">
 <TABLE style="padding: 5px">
 <TBODY><TR><TD colspan="2" style="padding-bottom:5px">Updated <SPAN title="Mon May  3 08:54:39 2010">May 03 (6 days ago)</SPAN>
 
 by <A style="white-space: nowrap" href="http://code.google.com/u/vladlosev/">vladlosev</A>
 </TD></TR>
 
 <TR><TH class="vt">Labels:</TH>
 <TD>
 
 <A href="http://code.google.com/p/googlemock/w/list?q=label:Featured" title="Listed on project home page">Featured</A>
 
 </TD>
 </TR>
 
 
 
 </TBODY></TABLE>
 </DIV>
 <DIV class="round1"></DIV>
 <DIV class="round2"></DIV>
 <DIV class="round4"></DIV>
 </DIV>
 </DIV>
 
 <DIV id="wikiheader" style="margin-bottom:1em">
 
 <SPAN style="font-size:120%;font-weight:bold">CookBook</SPAN>
 &nbsp;
 
 
 <DIV style="font-style:italic; margin-top: 3px">Google C++ Mocking Framework Cookbook</DIV>
 
 </DIV>
 <P></P><UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Creating_Mock_Classes">Creating Mock Classes</A></LI><UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Private_or_Protected_Methods">Mocking Private or Protected Methods</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Overloaded_Methods">Mocking Overloaded Methods</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Class_Templates">Mocking Class Templates</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Nonvirtual_Methods">Mocking Nonvirtual Methods</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Free_Functions">Mocking Free Functions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Nice_Mocks_and_Strict_Mocks">Nice Mocks and Strict Mocks</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Simplifying_the_Interface_without_Breaking_Existing_Code">Simplifying the Interface without Breaking Existing Code</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Alternative_to_Mocking_Concrete_Classes">Alternative to Mocking Concrete Classes</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Delegating_Calls_to_a_Fake">Delegating Calls to a Fake</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Delegating_Calls_to_a_Real_Object">Delegating Calls to a Real Object</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Delegating_Calls_to_a_Parent_Class">Delegating Calls to a Parent Class</A></LI></UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Matchers">Using Matchers</A></LI><UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Matching_Argument_Values_Exactly">Matching Argument Values Exactly</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Simple_Matchers">Using Simple Matchers</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Combining_Matchers">Combining Matchers</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Casting_Matchers">Casting Matchers</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Selecting_Between_Overloaded_Functions">Selecting Between Overloaded Functions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Performing_Different_Actions_Based_on_the_Arguments">Performing Different Actions Based on the Arguments</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Matching_Multiple_Arguments_as_a_Whole">Matching Multiple Arguments as a Whole</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Matchers_as_Predicates">Using Matchers as Predicates</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Matchers_in_Google_Test_Assertions">Using Matchers in Google Test Assertions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Predicates_as_Matchers">Using Predicates as Matchers</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Matching_Arguments_that_Are_Not_Copyable">Matching Arguments that Are Not Copyable</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Validating_a_Member_of_an_Object">Validating a Member of an Object</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Validating_the_Value_Pointed_to_by_a_Pointer_Argument">Validating the Value Pointed to by a Pointer Argument</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Testing_a_Certain_Property_of_an_Object">Testing a Certain Property of an Object</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Matching_Containers">Matching Containers</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Sharing_Matchers">Sharing Matchers</A></LI></UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Setting_Expectations">Setting Expectations</A></LI><UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Ignoring_Uninteresting_Calls">Ignoring Uninteresting Calls</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Disallowing_Unexpected_Calls">Disallowing Unexpected Calls</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Expecting_Ordered_Calls">Expecting Ordered Calls</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Expecting_Partially_Ordered_Calls">Expecting Partially Ordered Calls</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Controlling_When_an_Expectation_Retires">Controlling When an Expectation Retires</A></LI></UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Actions">Using Actions</A></LI><UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Returning_References_from_Mock_Methods">Returning References from Mock Methods</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Combining_Actions">Combining Actions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Side_Effects">Mocking Side Effects</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Changing_a_Mock_Object's_Behavior_Based_on_the_State">Changing a Mock Object's Behavior Based on the State</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Setting_the_Default_Value_for_a_Return_Type">Setting the Default Value for a Return Type</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Setting_the_Default_Actions_for_a_Mock_Method">Setting the Default Actions for a Mock Method</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Functions/Methods/Functors_as_Actions">Using Functions/Methods/Functors as Actions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Invoking_a_Function/Method/Functor_Without_Arguments">Invoking a Function/Method/Functor Without Arguments</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Invoking_an_Argument_of_the_Mock_Function">Invoking an Argument of the Mock Function</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Ignoring_an_Action's_Result">Ignoring an Action's Result</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Selecting_an_Action's_Arguments">Selecting an Action's Arguments</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Ignoring_Arguments_in_Action_Functions">Ignoring Arguments in Action Functions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Sharing_Actions">Sharing Actions</A></LI></UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Misc_Recipes_on_Using_Google_Mock">Misc Recipes on Using Google Mock</A></LI><UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Forcing_a_Verification">Forcing a Verification</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Check_Points">Using Check Points</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Destructors">Mocking Destructors</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_Google_Mock_and_Threads">Using Google Mock and Threads</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Controlling_How_Much_Information_Google_Mock_Prints">Controlling How Much Information Google Mock Prints</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Running_Tests_in_Emacs">Running Tests in Emacs</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Fusing_Google_Mock_Source_Files">Fusing Google Mock Source Files</A></LI></UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Extending_Google_Mock">Extending Google Mock</A></LI><UL><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Matchers_Quickly">Writing New Matchers Quickly</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Parameterized_Matchers_Quickly">Writing New Parameterized Matchers Quickly</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Monomorphic_Matchers">Writing New Monomorphic Matchers</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Polymorphic_Matchers">Writing New Polymorphic Matchers</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Cardinalities">Writing New Cardinalities</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Actions_Quickly">Writing New Actions Quickly</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Parameterized_Actions_Quickly">Writing New Parameterized Actions Quickly</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Restricting_the_Type_of_an_Argument_or_Parameter_in_an_ACTION">Restricting the Type of an Argument or Parameter in an ACTION</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Action_Templates_Quickly">Writing New Action Templates Quickly</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Using_the_ACTION_Object's_Type">Using the ACTION Object's Type</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Monomorphic_Actions">Writing New Monomorphic Actions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Writing_New_Polymorphic_Actions">Writing New Polymorphic Actions</A></LI><LI><A href="http://code.google.com/p/googlemock/wiki/CookBook#Teaching_Google_Mock_How_to_Print_Your_Values">Teaching Google Mock How to Print Your Values</A></LI></UL></UL> <P></P><P>You can find recipes for using Google Mock here. If you haven't yet, please read the <A href="http://code.google.com/p/googlemock/wiki/ForDummies">ForDummies</A> document first to make sure you understand the basics. </P><P><STRONG>Note:</STRONG> Google Mock lives in the <TT>testing</TT> name space. For readability, it is recommended to write <TT>using ::testing::Foo;</TT> once in your file before using the name <TT>Foo</TT> defined by Google Mock. We omit such <TT>using</TT> statements in this page for brevity, but you should do it in your own code. </P><H1><A name="Creating_Mock_Classes">Creating Mock Classes</A></H1><A name="Creating_Mock_Classes"></A><H2><A name="Mocking_Private_or_Protected_Methods">Mocking Private or Protected Methods</A></H2><A name="Mocking_Private_or_Protected_Methods"><P>You must always put a mock method definition (<TT>MOCK_METHOD*</TT>) in a <TT>public:</TT> section of the mock class, regardless of the method being mocked being <TT>public</TT>, <TT>protected</TT>, or <TT>private</TT> in the base class. This allows <TT>ON_CALL</TT> and <TT>EXPECT_CALL</TT> to reference the mock function from outside of the mock class.  (Yes, C++ allows a subclass to change the access level of a virtual function in the base class.)  Example: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Transform</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Gadget</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> g</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp;</SPAN><SPAN class="kwd">protected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Resume</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR>&nbsp;</SPAN><SPAN class="kwd">private</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetTimeOut</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Transform</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Gadget</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> g</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// The following must be in the public section, even though the</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// methods are protected or private in the base class.</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Resume</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetTimeOut</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE></A><H2><A name="Mocking_Overloaded_Methods">Mocking Overloaded Methods</A></H2><A name="Mocking_Overloaded_Methods"><P>You can mock overloaded functions as usual. No special attention is required: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Must be virtual as we'll inherit from Foo.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Overloaded on the types and/or numbers of arguments.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Element</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> times</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Element</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Overloaded on the const-ness of this object.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Element</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> times</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Element</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&amp;());</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_CONST_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&amp;());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P><STRONG>Note:</STRONG> if you don't mock all versions of the overloaded method, the compiler will give you a warning about some methods in the base class being hidden. To fix that, use <TT>using</TT> to bring them in scope: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Element</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// We don't want to mock int Add(int times, Element x);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE></A><H2><A name="Mocking_Class_Templates">Mocking Class Templates</A></H2><A name="Mocking_Class_Templates"><P>To mock a class template, append <TT>_T</TT> to the <TT>MOCK_*</TT> macros: </P><PRE class="prettyprint"><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Elem</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">StackInterface</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Must be virtual as we'll inherit from StackInterface.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">StackInterface</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetSize</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Push</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Elem</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Elem</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockStack</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">StackInterface</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">Elem</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_CONST_METHOD0_T</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetSize</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1_T</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Push</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Elem</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE></A><H2><A name="Mocking_Nonvirtual_Methods">Mocking Nonvirtual Methods</A></H2><A name="Mocking_Nonvirtual_Methods"><P>Google Mock can mock non-virtual functions to be used in what we call <I>hi-perf dependency injection</I>. </P><P>In this case, instead of sharing a common base class with the real class, your mock class will be <I>unrelated</I> to the real class, but contain methods with the same signatures.  The syntax for mocking non-virtual methods is the <I>same</I> as mocking virtual methods: </P><PRE class="prettyprint"><SPAN class="com">// A simple packet stream class. &nbsp;None of its members is virtual.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ConcretePacketStream</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">AppendPacket</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Packet</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> new_packet</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Packet</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetPacket</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">size_t packet_number</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; size_t </SPAN><SPAN class="typ">NumberOfPackets</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="com">// A mock packet stream class. &nbsp;It inherits from no other, but defines</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="com">// GetPacket() and NumberOfPackets().</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockPacketStream</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_CONST_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetPacket</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Packet</SPAN><SPAN class="pun">*(</SPAN><SPAN class="pln">size_t packet_number</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_CONST_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">NumberOfPackets</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> size_t</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>Note that the mock class doesn't define <TT>AppendPacket()</TT>, unlike the real class. That's fine as long as the test doesn't need to call it. </P><P>Next, you need a way to say that you want to use <TT>ConcretePacketStream</TT> in production code, and use <TT>MockPacketStream</TT> in tests.  Since the functions are not virtual and the two classes are unrelated, you must specify your choice at <I>compile time</I> (as opposed to run time). </P><P>One way to do it is to templatize your code that needs to use a packet stream.  More specifically, you will give your code a template type argument for the type of the packet stream.  In production, you will instantiate your template with <TT>ConcretePacketStream</TT> as the type argument.  In tests, you will instantiate the same template with <TT>MockPacketStream</TT>.  For example, you may write: </P><PRE class="prettyprint"><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">PacketStream</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">CreateConnection</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">PacketStream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> stream</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">PacketStream</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">PacketReader</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ReadPackets</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">PacketStream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> stream</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> size_t packet_num</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>Then you can use <TT>CreateConnection&lt;ConcretePacketStream&gt;()</TT> and <TT>PacketReader&lt;ConcretePacketStream&gt;</TT> in production code, and use <TT>CreateConnection&lt;MockPacketStream&gt;()</TT> and <TT>PacketReader&lt;MockPacketStream&gt;</TT> in tests. </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">MockPacketStream</SPAN><SPAN class="pln"> mock_stream</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_stream</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...)...;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">..</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">set</SPAN><SPAN class="pln"> more expectations on mock_stream </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">PacketReader</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">MockPacketStream</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> reader</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">mock_stream</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> exercise reader </SPAN><SPAN class="pun">...</SPAN></PRE></A><H2><A name="Mocking_Free_Functions">Mocking Free Functions</A></H2><A name="Mocking_Free_Functions"><P>It's possible to use Google Mock to mock a free function (i.e. a C-style function or a static method).  You just need to rewrite your code to use an interface (abstract class). </P><P>Instead of calling a free function (say, <TT>OpenFile</TT>) directly, introduce an interface for it and have a concrete subclass that calls the free function: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">FileInterface</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Open</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> path</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> mode</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">File</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">FileInterface</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Open</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> path</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> mode</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">OpenFile</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">path</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> mode</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>Your code should talk to <TT>FileInterface</TT> to open a file.  Now it's easy to mock out the function. </P><P>This may seem much hassle, but in practice you often have multiple related functions that you can put in the same interface, so the per-function syntactic overhead will be much lower. </P></A><P><A name="Mocking_Free_Functions">If you are concerned about the performance overhead incurred by virtual functions, and profiling confirms your concern, you can combine this with the recipe for </A><A href="http://code.google.com/p/googlemock/wiki/CookBook#Mocking_Nonvirtual_Methods">mocking non-virtual methods</A>. </P><H2><A name="Nice_Mocks_and_Strict_Mocks">Nice Mocks and Strict Mocks</A></H2><A name="Nice_Mocks_and_Strict_Mocks"><P>If a mock method has no <TT>EXPECT_CALL</TT> spec but is called, Google Mock will print a warning about the "uninteresting call". The rationale is: </P><UL><LI>New methods may be added to an interface after a test is written. We shouldn't fail a test just because a method it doesn't know about is called.  </LI><LI>However, this may also mean there's a bug in the test, so Google Mock shouldn't be silent either. If the user believes these calls are harmless, he can add an <TT>EXPECT_CALL()</TT> to suppress the warning.  </LI></UL><P>However, sometimes you may want to suppress all "uninteresting call" warnings, while sometimes you may want the opposite, i.e. to treat all of them as errors. Google Mock lets you make the decision on a per-mock-object basis. </P><P>Suppose your test uses a mock class <TT>MockFoo</TT>: </P><PRE class="prettyprint"><SPAN class="pln">TEST</SPAN><SPAN class="pun">(...)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> mock_foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> code that uses mock_foo </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>If a method of <TT>mock_foo</TT> other than <TT>DoThis()</TT> is called, it will be reported by Google Mock as a warning. However, if you rewrite your test to use <TT>NiceMock&lt;MockFoo&gt;</TT> instead, the warning will be gone, resulting in a cleaner test output: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">NiceMock</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>TEST</SPAN><SPAN class="pun">(...)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">NiceMock</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> mock_foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> code that uses mock_foo </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P><TT>NiceMock&lt;MockFoo&gt;</TT> is a subclass of <TT>MockFoo</TT>, so it can be used wherever <TT>MockFoo</TT> is accepted. </P><P>It also works if <TT>MockFoo</TT>'s constructor takes some arguments, as <TT>NiceMock&lt;MockFoo&gt;</TT> "inherits" <TT>MockFoo</TT>'s constructors: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">NiceMock</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>TEST</SPAN><SPAN class="pun">(...)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">NiceMock</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> mock_foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"hi"</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Calls MockFoo(5, "hi").</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> code that uses mock_foo </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>The usage of <TT>StrictMock</TT> is similar, except that it makes all uninteresting calls failures: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">StrictMock</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>TEST</SPAN><SPAN class="pun">(...)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">StrictMock</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> mock_foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> code that uses mock_foo </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// The test will fail if a method of mock_foo other than DoThis()</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// is called.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>There are some caveats though (I don't like them just as much as the next guy, but sadly they are side effects of C++'s limitations): </P></A><OL><A name="Nice_Mocks_and_Strict_Mocks"><LI><TT>NiceMock&lt;MockFoo&gt;</TT> and <TT>StrictMock&lt;MockFoo&gt;</TT> only work for mock methods defined using the <TT>MOCK_METHOD*</TT> family of macros <STRONG>directly</STRONG> in the <TT>MockFoo</TT> class. If a mock method is defined in a <STRONG>base class</STRONG> of <TT>MockFoo</TT>, the "nice" or "strict" modifier may not affect it, depending on the compiler. In particular, nesting <TT>NiceMock</TT> and <TT>StrictMock</TT> (e.g. <TT>NiceMock&lt;StrictMock&lt;MockFoo&gt; &gt;</TT>) is <STRONG>not</STRONG> supported.  </LI></A><LI><A name="Nice_Mocks_and_Strict_Mocks">The constructors of the base mock (<TT>MockFoo</TT>) cannot have arguments passed by non-const reference, which happens to be banned by the </A><A href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" rel="nofollow">Google C++ style guide</A>.  </LI><LI>During the constructor or destructor of <TT>MockFoo</TT>, the mock object is <I>not</I> nice or strict.  This may cause surprises if the constructor or destructor calls a mock method on <TT>this</TT> object. (This behavior, however, is consistent with C++'s general rule: if a constructor or destructor calls a virtual method of <TT>this</TT> object, that method is treated as non-virtual.  In other words, to the base class's constructor or destructor, <TT>this</TT> object behaves like an instance of the base class, not the derived class.  This rule is required for safety.  Otherwise a base constructor may use members of a derived class before they are initialized, or a base destructor may use members of a derived class after they have been destroyed.) </LI></OL><P>Finally, you should be <STRONG>very cautious</STRONG> when using this feature, as the decision you make applies to <STRONG>all</STRONG> future changes to the mock class. If an important change is made in the interface you are mocking (and thus in the mock class), it could break your tests (if you use <TT>StrictMock</TT>) or let bugs pass through without a warning (if you use <TT>NiceMock</TT>). Therefore, try to specify the mock's behavior using explicit <TT>EXPECT_CALL</TT> first, and only turn to <TT>NiceMock</TT> or <TT>StrictMock</TT> as the last resort. </P><H2><A name="Simplifying_the_Interface_without_Breaking_Existing_Code">Simplifying the Interface without Breaking Existing Code</A></H2><A name="Simplifying_the_Interface_without_Breaking_Existing_Code"><P>Sometimes a method has a long list of arguments that is mostly uninteresting. For example, </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">LogSink</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> send</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">LogSeverity</SPAN><SPAN class="pln"> severity</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> full_filename</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> base_filename</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> line</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">struct</SPAN><SPAN class="pln"> tm</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> tm_time</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> message</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> size_t message_len</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>This method's argument list is lengthy and hard to work with (let's say that the <TT>message</TT> argument is not even 0-terminated). If we mock it as is, using the mock will be awkward. If, however, we try to simplify this interface, we'll need to fix all clients depending on it, which is often infeasible. </P><P>The trick is to re-dispatch the method in the mock class: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ScopedMockLog</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">LogSink</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> send</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">LogSeverity</SPAN><SPAN class="pln"> severity</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> full_filename</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> base_filename</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> line</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> tm</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> tm_time</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> message</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> size_t message_len</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="com">// We are only interested in the log severity, full file name, and</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="com">// log message.</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">severity</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> full_filename</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> std</SPAN><SPAN class="pun">::</SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">message</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> message_len</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Implements the mock method:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">//</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// &nbsp; void Log(LogSeverity severity,</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const string&amp; file_path,</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const string&amp; message);</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD3</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">LogSeverity</SPAN><SPAN class="pln"> severity</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> file_path</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> message</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>By defining a new mock method with a trimmed argument list, we make the mock class much more user-friendly. </P></A><H2><A name="Alternative_to_Mocking_Concrete_Classes">Alternative to Mocking Concrete Classes</A></H2><A name="Alternative_to_Mocking_Concrete_Classes"><P>Often you may find yourself using classes that don't implement interfaces. In order to test your code that uses such a class (let's call it <TT>Concrete</TT>), you may be tempted to make the methods of <TT>Concrete</TT> virtual and then mock it. </P><P>Try not to do that. </P><P>Making a non-virtual function virtual is a big decision. It creates an extension point where subclasses can tweak your class' behavior. This weakens your control on the class because now it's harder to maintain the class' invariants. You should make a function virtual only when there is a valid reason for a subclass to override it. </P><P>Mocking concrete classes directly is problematic as it creates a tight coupling between the class and the tests - any small change in the class may invalidate your tests and make test maintenance a pain. </P><P>To avoid such problems, many programmers have been practicing "coding to interfaces": instead of talking to the <TT>Concrete</TT> class, your code would define an interface and talk to it. Then you implement that interface as an adaptor on top of <TT>Concrete</TT>. In tests, you can easily mock that interface to observe how your code is doing. </P><P>This technique incurs some overhead: </P><UL><LI>You pay the cost of virtual function calls (usually not a problem).  </LI><LI>There is more abstraction for the programmers to learn.  </LI></UL><P>However, it can also bring significant benefits in addition to better testability:   </P><UL><LI><TT>Concrete</TT>'s API may not fit your problem domain very well, as you may not be the only client it tries to serve. By designing your own interface, you have a chance to tailor it to your need - you may add higher-level functionalities, rename stuff, etc instead of just trimming the class. This allows you to write your code (user of the interface) in a more natural way, which means it will be more readable, more maintainable, and you'll be more productive.  </LI><LI>If <TT>Concrete</TT>'s implementation ever has to change, you don't have to rewrite everywhere it is used. Instead, you can absorb the change in your implementation of the interface, and your other code and tests will be insulated from this change.  </LI></UL><P></P><P>Some people worry that if everyone is practicing this technique, they will end up writing lots of redundant code. This concern is totally understandable. However, there are two reasons why it may not be the case:   </P><UL><LI>Different projects may need to use <TT>Concrete</TT> in different ways, so the best interfaces for them will be different. Therefore, each of them will have its own domain-specific interface on top of <TT>Concrete</TT>, and they will not be the same code.  </LI><LI>If enough projects want to use the same interface, they can always share it, just like they have been sharing <TT>Concrete</TT>. You can check in the interface and the adaptor somewhere near <TT>Concrete</TT> (perhaps in a <TT>contrib</TT> sub-directory) and let many projects use it.  </LI></UL><P></P><P>You need to weigh the pros and cons carefully for your particular problem, but I'd like to assure you that the Java community has been practicing this for a long time and it's a proven effective technique applicable in a wide variety of situations. :-) </P></A><H2><A name="Delegating_Calls_to_a_Fake">Delegating Calls to a Fake</A></H2><A name="Delegating_Calls_to_a_Fake"><P>Some times you have a non-trivial fake implementation of an interface. For example: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{}</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> s</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> p</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">FakeFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">n </SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">?</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">'+'</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">n </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">?</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">'-'</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">'0'</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> s</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> p</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">p </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> strlen</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>Now you want to mock this interface such that you can set expectations on it. However, you also want to use <TT>FakeFoo</TT> for the default behavior, as duplicating it in the mock object is, well, a lot of work. </P><P>When you define the mock class using Google Mock, you can have it delegate its default action to a fake class you already have, using this pattern: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Normal mock method definitions using Google Mock.</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> s</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> p</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Delegates the default actions of the methods to a FakeFoo object.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// This must be called *before* the custom ON_CALL() statements.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DelegateToFake</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; ON_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="kwd">this</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">fake_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="typ">FakeFoo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; ON_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="kwd">this</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">fake_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="typ">FakeFoo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">private</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">FakeFoo</SPAN><SPAN class="pln"> fake_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Keeps an instance of the fake in the mock.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>With that, you can use <TT>MockFoo</TT> in your tests as usual. Just remember that if you don't explicitly set an action in an <TT>ON_CALL()</TT> or <TT>EXPECT_CALL()</TT>, the fake will be called upon to do it: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>TEST</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AbcTest</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Xyz</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DelegateToFake</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> </SPAN><SPAN class="com">// Enables the fake for delegation.</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Put your ON_CALL(foo, ...)s here, if any.</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// No action specified, meaning to use the default action.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_EQ</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">'+'</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// FakeFoo::DoThis() is invoked.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Hi"</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln">n</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// FakeFoo::DoThat() is invoked.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_EQ</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P><STRONG>Some tips:</STRONG>   </P><UL><LI>If you want, you can still override the default action by providing your own <TT>ON_CALL()</TT> or using <TT>.WillOnce()</TT> / <TT>.WillRepeatedly()</TT> in <TT>EXPECT_CALL()</TT>.  </LI><LI>In <TT>DelegateToFake()</TT>, you only need to delegate the methods whose fake implementation you intend to use.  </LI><LI>The general technique discussed here works for overloaded methods, but you'll need to tell the compiler which version you mean. To disambiguate a mock function (the one you specify inside the parentheses of <TT>ON_CALL()</TT>), see the "Selecting Between Overloaded Functions" section on this page; to disambiguate a fake function (the one you place inside <TT>Invoke()</TT>), use a <TT>static_cast</TT> to specify the function's type.  </LI><LI>Having to mix a mock and a fake is often a sign of something gone wrong. Perhaps you haven't got used to the interaction-based way of testing yet. Or perhaps your interface is taking on too many roles and should be split up. Therefore, <STRONG>don't abuse this</STRONG>. We would only recommend to do it as an intermediate step when you are refactoring your code.  </LI></UL><P></P><P>Regarding the tip on mixing a mock and a fake, here's an example on why it may be a bad sign: Suppose you have a class <TT>System</TT> for low-level system operations. In particular, it does file and I/O operations. And suppose you want to test how your code uses <TT>System</TT> to do I/O, and you just want the file operations to work normally. If you mock out the entire <TT>System</TT> class, you'll have to provide a fake implementation for the file operation part, which suggests that <TT>System</TT> is taking on too many roles. </P><P>Instead, you can define a <TT>FileOps</TT> interface and an <TT>IOOps</TT> interface and split <TT>System</TT>'s functionalities into the two. Then you can mock <TT>IOOps</TT> without mocking <TT>FileOps</TT>. </P></A><H2><A name="Delegating_Calls_to_a_Real_Object">Delegating Calls to a Real Object</A></H2><A name="Delegating_Calls_to_a_Real_Object"><P>When using testing doubles (mocks, fakes, stubs, and etc), sometimes their behaviors will differ from those of the real objects. This difference could be either intentional (as in simulating an error such that you can test the error handling code) or unintentional. If your mocks have different behaviors than the real objects by mistake, you could end up with code that passes the tests but fails in production. </P><P>You can use the <I>delegating-to-real</I> technique to ensure that your mock has the same behavior as the real object while retaining the ability to validate calls. This technique is very similar to the delegating-to-fake technique, the difference being that we use a real object instead of a fake. Here's an example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">AtLeast</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="com">// By default, all calls are delegated to the real object.</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; ON_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="kwd">this</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">real_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; ON_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="kwd">this</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">real_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...);</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">private</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> real_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> mock</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Hi"</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AtLeast</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">use</SPAN><SPAN class="pln"> mock </SPAN><SPAN class="kwd">in</SPAN><SPAN class="pln"> test </SPAN><SPAN class="pun">...</SPAN></PRE><P>With this, Google Mock will verify that your code made the right calls (with the right arguments, in the right order, called the right number of times, etc), and a real object will answer the calls (so the behavior will be the same as in production). This gives you the best of both worlds. </P></A><H2><A name="Delegating_Calls_to_a_Parent_Class">Delegating Calls to a Parent Class</A></H2><A name="Delegating_Calls_to_a_Parent_Class"><P>Ideally, you should code to interfaces, whose methods are all pure virtual. In reality, sometimes you do need to mock a virtual method that is not pure (i.e, it already has an implementation). For example: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Pure</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Concrete</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> str</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Mocking a pure method.</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Pure</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Mocking a concrete method. &nbsp;Foo::Concrete() is shadowed.</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Concrete</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> str</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>Sometimes you may want to call <TT>Foo::Concrete()</TT> instead of <TT>MockFoo::Concrete()</TT>. Perhaps you want to do it as part of a stub action, or perhaps your test doesn't need to mock <TT>Concrete()</TT> at all (but it would be oh-so painful to have to define a new mock class whenever you don't need to mock one of its methods). </P><P>The trick is to leave a back door in your mock class for accessing the real methods in the base class: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Mocking a pure method.</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Pure</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Mocking a concrete method. &nbsp;Foo::Concrete() is shadowed.</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Concrete</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> str</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Use this to call Concrete() defined in Foo.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">FooConcrete</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> str</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Concrete</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">str</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>Now, you can call <TT>Foo::Concrete()</TT> inside an action by: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Concrete</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">FooConcrete</SPAN><SPAN class="pun">));</SPAN></PRE><P>or tell the mock object that you don't want to mock <TT>Concrete()</TT>: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; ON_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Concrete</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">FooConcrete</SPAN><SPAN class="pun">));</SPAN></PRE><P>(Why don't we just write <TT>Invoke(&amp;foo, &amp;Foo::Concrete)</TT>? If you do that, <TT>MockFoo::Concrete()</TT> will be called (and cause an infinite recursion) since <TT>Foo::Concrete()</TT> is virtual. That's just how C++ works.) </P></A><H1><A name="Using_Matchers">Using Matchers</A></H1><A name="Using_Matchers"></A><H2><A name="Matching_Argument_Values_Exactly">Matching Argument Values Exactly</A></H2><A name="Matching_Argument_Values_Exactly"><P>You can specify exactly which arguments a mock method is expecting:    </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">'a'</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Hello"</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> bar</SPAN><SPAN class="pun">));</SPAN></PRE></A><H2><A name="Using_Simple_Matchers">Using Simple Matchers</A></H2><A name="Using_Simple_Matchers"><P>You can use matchers to match arguments that have a certain property: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">)))</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// The argument must be &gt;= 5.</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">'a'</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Hello"</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">()));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// The second argument must not be NULL.</SPAN></PRE><P>A frequently used matcher is <TT>_</TT>, which matches anything: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">()));</SPAN></PRE></A><H2><A name="Combining_Matchers">Combining Matchers</A></H2><A name="Combining_Matchers"><P>You can build complex matchers from existing ones using <TT>AllOf()</TT>, <TT>AnyOf()</TT>, and <TT>Not()</TT>: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">HasSubstr</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Ne</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Not</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// The argument must be &gt; 5 and != 10.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="typ">Ne</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">10</SPAN><SPAN class="pun">))));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// The first argument must not contain sub-string "blah".</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Not</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">HasSubstr</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"blah"</SPAN><SPAN class="pun">)),</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL</SPAN><SPAN class="pun">));</SPAN></PRE></A><H2><A name="Casting_Matchers">Casting Matchers</A></H2><A name="Casting_Matchers"><P>Google Mock matchers are statically typed, meaning that the compiler can catch your mistake if you use a matcher of the wrong type (for example, if you use <TT>Eq(5)</TT> to match a <TT>string</TT> argument). Good for you! </P><P>Sometimes, however, you know what you're doing and want the compiler to give you some slack. One example is that you have a matcher for <TT>long</TT> and the argument you want to match is <TT>int</TT>. While the two types aren't exactly the same, there is nothing really wrong with using a <TT>Matcher&lt;long&gt;</TT> to match an <TT>int</TT> - after all, we can first convert the <TT>int</TT> argument to a <TT>long</TT> before giving it to the matcher. </P><P>To support this need, Google Mock gives you the <TT>SafeMatcherCast&lt;T&gt;(m)</TT> function. It casts a matcher <TT>m</TT> to type <TT>Matcher&lt;T&gt;</TT>. To ensure safety, Google Mock checks that (let <TT>U</TT> be the type <TT>m</TT> accepts): </P><OL><LI>Type <TT>T</TT> can be implicitly cast to type <TT>U</TT>; </LI><LI>When both <TT>T</TT> and <TT>U</TT> are built-in arithmetic types (<TT>bool</TT>, integers, and floating-point numbers), the conversion from <TT>T</TT> to <TT>U</TT> is not lossy (in other words, any value representable by <TT>T</TT> can also be represented by <TT>U</TT>); and </LI><LI>When <TT>U</TT> is a reference, <TT>T</TT> must also be a reference (as the underlying matcher may be interested in the address of the <TT>U</TT> value). </LI></OL><P>The code won't compile if any of these conditions isn't met.  </P><P>Here's one example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">SafeMatcherCast</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="com">// A base class and a child class.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Base</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Derived</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Base</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Derived</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> derived</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// m is a Matcher&lt;Base*&gt; we got from somewhere.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">SafeMatcherCast</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">Derived</SPAN><SPAN class="pun">*&gt;(</SPAN><SPAN class="pln">m</SPAN><SPAN class="pun">)));</SPAN></PRE><P>If you find <TT>SafeMatcherCast&lt;T&gt;(m)</TT> too limiting, you can use a similar function <TT>MatcherCast&lt;T&gt;(m)</TT>. The difference is that <TT>MatcherCast</TT> works as long as you can <TT>static_cast</TT> type <TT>T</TT> to type <TT>U</TT>. </P><P><TT>MatcherCast</TT> essentially lets you bypass C++'s type system (<TT>static_cast</TT> isn't always safe as it could throw away information, for example), so be careful not to misuse/abuse it. </P></A><H2><A name="Selecting_Between_Overloaded_Functions">Selecting Between Overloaded Functions</A></H2><A name="Selecting_Between_Overloaded_Functions"><P>If you expect an overloaded function to be called, the compiler may need some help on which overloaded version it is. </P><P>To disambiguate functions overloaded on the const-ness of this object, use the <TT>Const()</TT> argument wrapper. </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ReturnRef</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&amp;());</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_CONST_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&amp;());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pln"> bar1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> bar2</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// The non-const GetBar().</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnRef</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar1</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Const</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// The const GetBar().</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnRef</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar2</SPAN><SPAN class="pun">));</SPAN></PRE><P>(<TT>Const()</TT> is defined by Google Mock and returns a <TT>const</TT> reference to its argument.) </P><P>To disambiguate overloaded functions with the same number of arguments but different argument types, you may need to specify the exact type of a matcher, either by wrapping your matcher in <TT>Matcher&lt;type&gt;()</TT>, or using a matcher whose type is fixed (<TT>TypedEq&lt;type&gt;</TT>, <TT>An&lt;type&gt;()</TT>, etc): </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">An</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Matcher</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">TypedEq</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockPrinter</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Printer</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">char</SPAN><SPAN class="pln"> c</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR>TEST</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">PrinterTest</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MockPrinter</SPAN><SPAN class="pln"> printer</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">printer</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">An</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pun">()));</SPAN><SPAN class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="com">// void Print(int);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">printer</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Matcher</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">))));</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// void Print(int);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">printer</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">TypedEq</SPAN><SPAN class="str">&lt;char&gt;</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">'a'</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"> &nbsp; </SPAN><SPAN class="com">// void Print(char);</SPAN><SPAN class="pln"><BR><BR>&nbsp; printer</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; printer</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; printer</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Print</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">'a'</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE></A><H2><A name="Performing_Different_Actions_Based_on_the_Arguments">Performing Different Actions Based on the Arguments</A></H2><A name="Performing_Different_Actions_Based_on_the_Arguments"><P>When a mock method is called, the <I>last</I> matching expectation that's still active will be selected (think "newer overrides older"). So, you can make a method do different things depending on its argument values like this: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// The default case.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">'b'</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// The more specific case.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">)))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">'a'</SPAN><SPAN class="pun">));</SPAN></PRE><P>Now, if <TT>foo.DoThis()</TT> is called with a value less than 5, <TT>'a'</TT> will be returned; otherwise <TT>'b'</TT> will be returned. </P></A><H2><A name="Matching_Multiple_Arguments_as_a_Whole">Matching Multiple Arguments as a Whole</A></H2><A name="Matching_Multiple_Arguments_as_a_Whole"><P>Sometimes it's not enough to match the arguments individually. For example, we may want to say that the first argument must be less than the second argument. The <TT>With()</TT> clause allows us to match all arguments of a mock function as a whole. For example, </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Ne</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">InRange</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Ne</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">With</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">());</SPAN></PRE><P>says that the first argument of <TT>InRange()</TT> must not be 0, and must be less than the second argument. </P><P>The expression inside <TT>With()</TT> must be a matcher of type <TT>Matcher&lt;tr1::tuple&lt;A1, ..., An&gt; &gt;</TT>, where <TT>A1</TT>, ..., <TT>An</TT> are the types of the function arguments. </P><P>You can also write <TT>AllArgs(m)</TT> instead of <TT>m</TT> inside <TT>.With()</TT>. The two forms are equivalent, but <TT>.With(AllArgs(Lt()))</TT> is more readable than <TT>.With(Lt())</TT>. </P><P>You can use <TT>Args&lt;k1, ..., kn&gt;(m)</TT> to match the <TT>n</TT> selected arguments against <TT>m</TT>. For example, </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Args</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Blah</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">With</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Args</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">()),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Args</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">())));</SPAN></PRE><P>says that <TT>Blah()</TT> will be called with arguments <TT>x</TT>, <TT>y</TT>, and <TT>z</TT> where <TT>x &lt; y &lt; z</TT>. </P></A><P><A name="Matching_Multiple_Arguments_as_a_Whole">As a convenience and example, Google Mock provides some matchers for 2-tuples, including the <TT>Lt()</TT> matcher above. See the </A><A href="http://code.google.com/p/googlemock/wiki/CheatSheet">CheatSheet</A> for the complete list. </P><H2><A name="Using_Matchers_as_Predicates">Using Matchers as Predicates</A></H2><A name="Using_Matchers_as_Predicates"><P>Have you noticed that a matcher is just a fancy predicate that also knows how to describe itself? Many existing algorithms take predicates as arguments (e.g. those defined in STL's <TT>&lt;algorithm&gt;</TT> header), and it would be a shame if Google Mock matchers are not allowed to participate. </P><P>Luckily, you can use a matcher where a unary predicate functor is expected by wrapping it inside the <TT>Matches()</TT> function. For example, </P><PRE class="prettyprint"><SPAN class="com">#include</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">&lt;algorithm&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="com">#include</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">&lt;vector&gt;</SPAN><SPAN class="pln"><BR><BR>std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">vector</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pln"> v</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="com">// How many elements in v are &gt;= 10?</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> count </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> count_if</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">v</SPAN><SPAN class="pun">.</SPAN><SPAN class="kwd">begin</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> v</SPAN><SPAN class="pun">.</SPAN><SPAN class="kwd">end</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Matches</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">10</SPAN><SPAN class="pun">)));</SPAN></PRE><P>Since you can build complex matchers from simpler ones easily using Google Mock, this gives you a way to conveniently construct composite predicates (doing the same using STL's <TT>&lt;functional&gt;</TT> header is just painful). For example, here's a predicate that's satisfied by any number that is &gt;= 0, &lt;= 100, and != 50: </P><PRE class="prettyprint"><SPAN class="typ">Matches</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Le</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">100</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Ne</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">50</SPAN><SPAN class="pun">)))</SPAN></PRE></A><H2><A name="Using_Matchers_in_Google_Test_Assertions">Using Matchers in Google Test Assertions</A></H2><A name="Using_Matchers_in_Google_Test_Assertions"></A><P><A name="Using_Matchers_in_Google_Test_Assertions">Since matchers are basically predicates that also know how to describe themselves, there is a way to take advantage of them in </A><A href="http://code.google.com/p/googletest/" rel="nofollow">Google Test</A> assertions. It's called <TT>ASSERT_THAT</TT> and <TT>EXPECT_THAT</TT>: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; ASSERT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">value</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> matcher</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Asserts that value matches matcher.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">value</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> matcher</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// The non-fatal version.</SPAN></PRE><P>For example, in a Google Test test you can write: </P><PRE class="prettyprint"><SPAN class="com">#include</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">&lt;gmock/gmock.h&gt;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Le</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MatchesRegex</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">StartsWith</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">StartsWith</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Hello"</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchesRegex</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Line \\d+"</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; ASSERT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Baz</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Le</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">10</SPAN><SPAN class="pun">)));</SPAN></PRE><P>which (as you can probably guess) executes <TT>Foo()</TT>, <TT>Bar()</TT>, and <TT>Baz()</TT>, and verifies that:   </P><UL><LI><TT>Foo()</TT> returns a string that starts with <TT>"Hello"</TT>.  </LI><LI><TT>Bar()</TT> returns a string that matches regular expression <TT>"Line \\d+"</TT>.  </LI><LI><TT>Baz()</TT> returns a number in the range 10.  </LI></UL><P></P><P>The nice thing about these macros is that <I>they read like English</I>. They generate informative messages too. For example, if the first <TT>EXPECT_THAT()</TT> above fails, the message will be something like: </P><PRE class="prettyprint"><SPAN class="typ">Value</SPAN><SPAN class="pln"> of</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Actual</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"Hi, world!"</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="typ">Expected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> starts </SPAN><SPAN class="kwd">with</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"Hello"</SPAN></PRE><P><STRONG>Credit:</STRONG> The idea of <TT>(ASSERT|EXPECT)_THAT</TT> was stolen from the <A href="http://code.google.com/p/hamcrest/" rel="nofollow">Hamcrest</A> project, which adds <TT>assertThat()</TT> to JUnit. </P><H2><A name="Using_Predicates_as_Matchers">Using Predicates as Matchers</A></H2><A name="Using_Predicates_as_Matchers"><P>Google Mock provides a built-in set of matchers. In case you find them lacking, you can use an arbitray unary predicate function or functor as a matcher - as long as the predicate accepts a value of the type you want. You do this by wrapping the predicate inside the <TT>Truly()</TT> function, for example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Truly</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsEven</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">n </SPAN><SPAN class="pun">%</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">?</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">1</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Bar() must be called with an even number.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Truly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IsEven</SPAN><SPAN class="pun">)));</SPAN></PRE><P>Note that the predicate function / functor doesn't have to return <TT>bool</TT>. It works as long as the return value can be used as the condition in statement <TT>if (condition) ...</TT>. </P></A><H2><A name="Matching_Arguments_that_Are_Not_Copyable">Matching Arguments that Are Not Copyable</A></H2><A name="Matching_Arguments_that_Are_Not_Copyable"><P>When you do an <TT>EXPECT_CALL(mock_obj, Foo(bar))</TT>, Google Mock saves away a copy of <TT>bar</TT>. When <TT>Foo()</TT> is called later, Google Mock compares the argument to <TT>Foo()</TT> with the saved copy of <TT>bar</TT>. This way, you don't need to worry about <TT>bar</TT> being modified or destroyed after the <TT>EXPECT_CALL()</TT> is executed. The same is true when you use matchers like <TT>Eq(bar)</TT>, <TT>Le(bar)</TT>, and so on. </P><P>But what if <TT>bar</TT> cannot be copied (i.e. has no copy constructor)? You could define your own matcher function and use it with <TT>Truly()</TT>, as the previous couple of recipes have shown. Or, you may be able to get away from it if you can guarantee that <TT>bar</TT> won't be changed after the <TT>EXPECT_CALL()</TT> is executed. Just tell Google Mock that it should save a reference to <TT>bar</TT>, instead of a copy of it. Here's how: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Eq</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ByRef</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Expects that Foo()'s argument == bar.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_obj</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Eq</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ByRef</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">))));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Expects that Foo()'s argument &lt; bar.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_obj</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Lt</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ByRef</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">))));</SPAN></PRE><P>Remember: if you do this, don't change <TT>bar</TT> after the <TT>EXPECT_CALL()</TT>, or the result is undefined. </P></A><H2><A name="Validating_a_Member_of_an_Object">Validating a Member of an Object</A></H2><A name="Validating_a_Member_of_an_Object"><P>Often a mock function takes a reference to object as an argument. When matching the argument, you may not want to compare the entire object against a fixed object, as that may be over-specification. Instead, you may need to validate a certain member variable or the result of a certain getter method of the object. You can do this with <TT>Field()</TT> and <TT>Property()</TT>. More specifically, </P><PRE class="prettyprint"><SPAN class="typ">Field</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> m</SPAN><SPAN class="pun">)</SPAN></PRE><P>is a matcher that matches a <TT>Foo</TT> object whose <TT>bar</TT> member variable satisfies matcher <TT>m</TT>. </P><PRE class="prettyprint"><SPAN class="typ">Property</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">baz</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> m</SPAN><SPAN class="pun">)</SPAN></PRE><P>is a matcher that matches a <TT>Foo</TT> object whose <TT>baz()</TT> method returns a value that satisfies matcher <TT>m</TT>. </P><P>For example: </P><BLOCKQUOTE><TABLE><TBODY><TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>Field(&amp;Foo::number, Ge(3))</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> Matches <TT>x</TT> where <TT>x.number &gt;= 3</TT>. </TD></TR> </TBODY></TABLE>
<TABLE><TBODY><TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>Property(&amp;Foo::name, StartsWith("John "))</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> Matches <TT>x</TT> where <TT>x.name()</TT> starts with <TT>"John "</TT>. </TD></TR> </TBODY></TABLE>
</BLOCKQUOTE><P>  Note that in <TT>Property(&amp;Foo::baz, ...)</TT>, method <TT>baz()</TT> must take no argument and be declared as <TT>const</TT>. </P><P>BTW, <TT>Field()</TT> and <TT>Property()</TT> can also match plain pointers to objects. For instance, </P><PRE class="prettyprint"><SPAN class="typ">Field</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">number</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">))</SPAN></PRE><P>matches a plain pointer <TT>p</TT> where <TT>p-&gt;number &gt;= 3</TT>. If <TT>p</TT> is <TT>NULL</TT>, the match will always fail regardless of the inner matcher. </P><P>What if you want to validate more than one members at the same time? Remember that there is <TT>AllOf()</TT>. </P></A><H2><A name="Validating_the_Value_Pointed_to_by_a_Pointer_Argument">Validating the Value Pointed to by a Pointer Argument</A></H2><A name="Validating_the_Value_Pointed_to_by_a_Pointer_Argument"><P>C++ functions often take pointers as arguments. You can use matchers like <TT>NULL</TT>, <TT>NotNull()</TT>, and other comparison matchers to match a pointer, but what if you want to make sure the value <I>pointed to</I> by the pointer, instead of the pointer itself, has a certain property? Well, you can use the <TT>Pointee(m)</TT> matcher. </P><P><TT>Pointee(m)</TT> matches a pointer iff <TT>m</TT> matches the value the pointer points to. For example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Pointee</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Pointee</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Ge</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">))));</SPAN></PRE><P>expects <TT>foo.Bar()</TT> to be called with a pointer that points to a value greater than or equal to 3. </P><P>One nice thing about <TT>Pointee()</TT> is that it treats a <TT>NULL</TT> pointer as a match failure, so you can write <TT>Pointee(m)</TT> instead of </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Pointee</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">m</SPAN><SPAN class="pun">))</SPAN></PRE><P>without worrying that a <TT>NULL</TT> pointer will crash your test. </P><P>Also, did we tell you that <TT>Pointee()</TT> works with both raw pointers <STRONG>and</STRONG> smart pointers (<TT>linked_ptr</TT>, <TT>shared_ptr</TT>, <TT>scoped_ptr</TT>, and etc)? </P><P>What if you have a pointer to pointer? You guessed it - you can use nested <TT>Pointee()</TT> to probe deeper inside the value. For example, <TT>Pointee(Pointee(Lt(3)))</TT> matches a pointer that points to a pointer that points to a number less than 3 (what a mouthful...). </P></A><H2><A name="Testing_a_Certain_Property_of_an_Object">Testing a Certain Property of an Object</A></H2><A name="Testing_a_Certain_Property_of_an_Object"><P>Sometimes you want to specify that an object argument has a certain property, but there is no existing matcher that does this. If you want good error messages, you should define a matcher. If you want to do it quick and dirty, you could get away with writing an ordinary function. </P><P>Let's say you have a mock function that takes an object of type <TT>Foo</TT>, which has an <TT>int bar()</TT> method and an <TT>int baz()</TT> method, and you want to constrain that the argument's <TT>bar()</TT> value plus its <TT>baz()</TT> value is a given number. Here's how you can define a matcher to do it: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MatcherInterface</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">BarPlusBazEqMatcher</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatcherInterface</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">&amp;&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">explicit</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">BarPlusBazEqMatcher</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> expected_sum</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> expected_sum_</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">expected_sum</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchAndExplain</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> listener</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="pln">baz</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> expected_sum_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"bar() + baz() equals "</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> expected_sum_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeNegationTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"bar() + baz() does not equal "</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> expected_sum_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">private</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> expected_sum_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">inline</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Matcher</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">&amp;&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">BarPlusBazEq</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> expected_sum</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MakeMatcher</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">BarPlusBazEqMatcher</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">expected_sum</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(...,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">BarPlusBazEq</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">)))...;</SPAN></PRE></A><H2><A name="Matching_Containers">Matching Containers</A></H2><A name="Matching_Containers"><P>Sometimes an STL container (e.g. list, vector, map, ...) is passed to a mock function and you may want to validate it. Since most STL containers support the <TT>==</TT> operator, you can write <TT>Eq(expected_container)</TT> or simply <TT>expected_container</TT> to match a container exactly. </P><P>Sometimes, though, you may want to be more flexible (for example, the first element must be an exact match, but the second element can be any positive number, and so on). Also, containers used in tests often have a small number of elements, and having to define the expected container out-of-line is a bit of a hassle. </P><P>You can use the <TT>ElementsAre()</TT> matcher in such cases: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ElementsAre</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> vector</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> numbers</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ElementsAre</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">)));</SPAN></PRE><P>The above matcher says that the container must have 4 elements, which must be 1, greater than 0, anything, and 5 respectively. </P><P><TT>ElementsAre()</TT> is overloaded to take 0 to 10 arguments. If more are needed, you can place them in a C-style array and use <TT>ElementsAreArray()</TT> instead: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ElementsAreArray</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// ElementsAreArray accepts an array of element values.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> expected_vector1</SPAN><SPAN class="pun">[]</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">4</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ElementsAreArray</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">expected_vector1</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Or, an array of element matchers.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Matcher</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pln"> expected_vector2 </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ElementsAreArray</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">expected_vector2</SPAN><SPAN class="pun">)));</SPAN></PRE><P>In case the array needs to be dynamically created (and therefore the array size cannot be inferred by the compiler), you can give <TT>ElementsAreArray()</TT> an additional argument to specify the array size: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ElementsAreArray</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> expected_vector3 </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">[</SPAN><SPAN class="pln">count</SPAN><SPAN class="pun">];</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> fill expected_vector3 </SPAN><SPAN class="kwd">with</SPAN><SPAN class="pln"> values </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ElementsAreArray</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">expected_vector3</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> count</SPAN><SPAN class="pun">)));</SPAN></PRE><P><STRONG>Tips:</STRONG>   </P><UL><LI><TT>ElementAre*()</TT> works with <I>any</I> container that implements the STL iterator concept (i.e. it has a <TT>const_iterator</TT> type and supports <TT>begin()/end()</TT>) and supports <TT>size()</TT>, not just the ones defined in STL. It will even work with container types yet to be written - as long as they follows the above pattern.  </LI><LI>You can use nested <TT>ElementAre*()</TT> to match nested (multi-dimensional) containers.  </LI><LI>If the container is passed by pointer instead of by reference, just write <TT>Pointee(ElementsAre*(...))</TT>.  </LI><LI>The order of elements <I>matters</I> for <TT>ElementsAre*()</TT>. Therefore don't use it with containers whose element order is undefined (e.g. <TT>hash_map</TT>).  </LI></UL><P></P></A><H2><A name="Sharing_Matchers">Sharing Matchers</A></H2><A name="Sharing_Matchers"><P>Under the hood, a Google Mock matcher object consists of a pointer to a ref-counted implementation object. Copying matchers is allowed and very efficient, as only the pointer is copied. When the last matcher that references the implementation object dies, the implementation object will be deleted. </P><P>Therefore, if you have some complex matcher that you want to use again and again, there is no need to build it everytime. Just assign it to a matcher variable and use that variable repeatedly! For example, </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Matcher</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pln"> in_range </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">AllOf</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Le</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">10</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">use</SPAN><SPAN class="pln"> in_range </SPAN><SPAN class="kwd">as</SPAN><SPAN class="pln"> a matcher </SPAN><SPAN class="kwd">in</SPAN><SPAN class="pln"> multiple EXPECT_CALLs </SPAN><SPAN class="pun">...</SPAN></PRE></A><H1><A name="Setting_Expectations">Setting Expectations</A></H1><A name="Setting_Expectations"></A><H2><A name="Ignoring_Uninteresting_Calls">Ignoring Uninteresting Calls</A></H2><A name="Ignoring_Uninteresting_Calls"><P>If you are not interested in how a mock method is called, just don't say anything about it. In this case, if the method is ever called, Google Mock will perform its default action to allow the test program to continue. If you are not happy with the default action taken by Google Mock, you can override it using <TT>DefaultValue&lt;T&gt;::Set()</TT> (described later in this document) or <TT>ON_CALL()</TT>. </P><P>Please note that once you expressed interest in a particular mock method (via <TT>EXPECT_CALL()</TT>), all invocations to it must match some expectation. If this function is called but the arguments don't match any <TT>EXPECT_CALL()</TT> statement, it will be an error. </P></A><H2><A name="Disallowing_Unexpected_Calls">Disallowing Unexpected Calls</A></H2><A name="Disallowing_Unexpected_Calls"><P>If a mock method shouldn't be called at all, explicitly say so: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">);</SPAN></PRE><P>If some calls to the method are allowed, but the rest are not, just list all the expected calls: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">AnyNumber</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">10</SPAN><SPAN class="pun">)))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AnyNumber</SPAN><SPAN class="pun">());</SPAN></PRE><P>A call to <TT>foo.Bar()</TT> that doesn't match any of the <TT>EXPECT_CALL()</TT> statements will be an error. </P></A><H2><A name="Expecting_Ordered_Calls">Expecting Ordered Calls</A></H2><A name="Expecting_Ordered_Calls"><P>Although an <TT>EXPECT_CALL()</TT> statement defined earlier takes precedence when Google Mock tries to match a function call with an expectation, by default calls don't have to happen in the order <TT>EXPECT_CALL()</TT> statements are written. For example, if the arguments match the matchers in the third <TT>EXPECT_CALL()</TT>, but not those in the first two, then the third expectation will be used. </P><P>If you would rather have all calls occur in the order of the expectations, put the <TT>EXPECT_CALL()</TT> statements in a block where you define a variable of type <TT>InSequence</TT>: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pln"> s</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN></PRE><P>In this example, we expect a call to <TT>foo.DoThis(5)</TT>, followed by two calls to <TT>bar.DoThat()</TT> where the argument can be anything, which are in turn followed by a call to <TT>foo.DoThis(6)</TT>. If a call occurred out-of-order, Google Mock will report an error. </P></A><H2><A name="Expecting_Partially_Ordered_Calls">Expecting Partially Ordered Calls</A></H2><A name="Expecting_Partially_Ordered_Calls"><P>Sometimes requiring everything to occur in a predetermined order can lead to brittle tests. For example, we may care about <TT>A</TT> occurring before both <TT>B</TT> and <TT>C</TT>, but aren't interested in the relative order of <TT>B</TT> and <TT>C</TT>. In this case, the test should reflect our real intent, instead of being overly constraining. </P></A><P><A name="Expecting_Partially_Ordered_Calls">Google Mock allows you to impose an arbitrary DAG (directed acyclic graph) on the calls. One way to express the DAG is to use the </A><A href="http://code.google.com/p/googlemock/wiki/CheatSheet#The_After_Clause">After</A> clause of <TT>EXPECT_CALL</TT>. </P><P>Another way is via the <TT>InSequence()</TT> clause (not the same as the <TT>InSequence</TT> class), which we borrowed from jMock 2. It's less flexible than <TT>After()</TT>, but more convenient when you have long chains of sequential calls, as it doesn't require you to come up with different names for the expectations in the chains.  Here's how it works: </P><P>If we view <TT>EXPECT_CALL()</TT> statements as nodes in a graph, and add an edge from node A to node B wherever A must occur before B, we can get a DAG. We use the term "sequence" to mean a directed path in this DAG. Now, if we decompose the DAG into sequences, we just need to know which sequences each <TT>EXPECT_CALL()</TT> belongs to in order to be able to reconstruct the orginal DAG. </P><P>So, to specify the partial order on the expectations we need to do two things: first to define some <TT>Sequence</TT> objects, and then for each <TT>EXPECT_CALL()</TT> say which <TT>Sequence</TT> objects it is part of. Expectations in the same sequence must occur in the order they are written. For example, </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Sequence</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">Sequence</SPAN><SPAN class="pln"> s1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> s2</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> A</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> s2</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> B</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s1</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> C</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s2</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> D</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s2</SPAN><SPAN class="pun">);</SPAN></PRE><P>specifies the following DAG (where <TT>s1</TT> is <TT>A -&gt; B</TT>, and <TT>s2</TT> is `A -&gt; C -&gt; D`): </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="pun">+---&gt;</SPAN><SPAN class="pln"> B<BR>&nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="pun">|</SPAN><SPAN class="pln"><BR>&nbsp; A </SPAN><SPAN class="pun">---|</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="pun">|</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="pun">+---&gt;</SPAN><SPAN class="pln"> C </SPAN><SPAN class="pun">---&gt;</SPAN><SPAN class="pln"> D</SPAN></PRE><P>This means that A must occur before B and C, and C must occur before D. There's no restriction about the order other than these. </P><H2><A name="Controlling_When_an_Expectation_Retires">Controlling When an Expectation Retires</A></H2><A name="Controlling_When_an_Expectation_Retires"><P>When a mock method is called, Google Mock only consider expectations that are still active. An expectation is active when created, and becomes inactive (aka <I>retires</I>) when a call that has to occur later has occurred. For example, in </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Sequence</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">Sequence</SPAN><SPAN class="pln"> s1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> s2</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">WARNING</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"File too large."</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"> &nbsp; &nbsp; </SPAN><SPAN class="com">// #1</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AnyNumber</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> s2</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">WARNING</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"Data set is empty."</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// #2</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s1</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">WARNING</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"User not found."</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"> &nbsp; &nbsp; </SPAN><SPAN class="com">// #3</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">s2</SPAN><SPAN class="pun">);</SPAN></PRE><P>as soon as either #2 or #3 is matched, #1 will retire. If a warning <TT>"File too large."</TT> is logged after this, it will be an error. </P><P>Note that an expectation doesn't retire automatically when it's saturated. For example, </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">WARNING</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="com">// #1</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">WARNING</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"File too large."</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// #2</SPAN></PRE><P>says that there will be exactly one warning with the message `"File too large."`. If the second warning contains this message too, #2 will match again and result in an upper-bound-violated error. </P><P>If this is not what you want, you can ask an expectation to retire as soon as it becomes saturated: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">WARNING</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// #1</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">log</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Log</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">WARNING</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"File too large."</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// #2</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">RetiresOnSaturation</SPAN><SPAN class="pun">();</SPAN></PRE><P>Here #2 can be used only once, so if you have two warnings with the message <TT>"File too large."</TT>, the first will match #2 and the second will match #1 - there will be no error. </P></A><H1><A name="Using_Actions">Using Actions</A></H1><A name="Using_Actions"></A><H2><A name="Returning_References_from_Mock_Methods">Returning References from Mock Methods</A></H2><A name="Returning_References_from_Mock_Methods"><P>If a mock function's return type is a reference, you need to use <TT>ReturnRef()</TT> instead of <TT>Return()</TT> to return a result: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ReturnRef</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&amp;());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pln"> bar</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetBar</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnRef</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">));</SPAN></PRE></A><H2><A name="Combining_Actions">Combining Actions</A></H2><A name="Combining_Actions"><P>Want to do more than one thing when a function is called? That's fine. <TT>DoAll()</TT> allow you to do sequence of actions every time. Only the return value of the last action in the sequence will be used. </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">DoAll</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoAll</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">action_1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action_2</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action_n</SPAN><SPAN class="pun">));</SPAN></PRE></A><H2><A name="Mocking_Side_Effects">Mocking Side Effects</A></H2><A name="Mocking_Side_Effects"><P>Sometimes a method exhibits its effect not via returning a value but via side effects. For example, it may change some global state or modify an output argument. To mock side effects, in general you can define your own action by implementing <TT>::testing::ActionInterface</TT>. </P><P>If all you need to do is to change an output argument, the built-in <TT>SetArgumentPointee()</TT> action is convenient: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">SetArgumentPointee</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockMutator</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Mutator</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Mutate</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> mutate</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> value</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockMutator</SPAN><SPAN class="pln"> mutator</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mutator</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Mutate</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">true</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">SetArgumentPointee</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN></PRE><P>In this example, when <TT>mutator.Mutate()</TT> is called, we will assign 5 to the <TT>int</TT> variable pointed to by argument #1 (0-based). </P><P><TT>SetArgumentPointee()</TT> conveniently makes an internal copy of the value you pass to it, removing the need to keep the value in scope and alive. The implication however is that the value must have a copy constructor and assignment operator. </P><P>If the mock method also needs to return a value as well, you can chain <TT>SetArgumentPointee()</TT> with <TT>Return()</TT> using <TT>DoAll()</TT>: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">SetArgumentPointee</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockMutator</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Mutator</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">MutateInt</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> value</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockMutator</SPAN><SPAN class="pln"> mutator</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mutator</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MutateInt</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoAll</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">SetArgumentPointee</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">true</SPAN><SPAN class="pun">)));</SPAN></PRE><P>If the output argument is an array, use the <TT>SetArrayArgument&lt;N&gt;(first, last)</TT> action instead. It copies the elements in source range <TT>[first, last)</TT> to the array pointed to by the <TT>N</TT>-th (0-based) argument: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">SetArrayArgument</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockArrayMutator</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ArrayMutator</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Mutate</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> values</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> num_values</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockArrayMutator</SPAN><SPAN class="pln"> mutator</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> values</SPAN><SPAN class="pun">[</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">]</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">4</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">5</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mutator</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Mutate</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">SetArrayArgument</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">values</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> values </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN></PRE><P>This also works when the argument is an output iterator: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">SeArrayArgument</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockRolodex</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Rolodex</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">GetNames</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">back_insert_iterator</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">vector</SPAN><SPAN class="str">&lt;string&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&gt;));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockRolodex</SPAN><SPAN class="pln"> rolodex</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; vector</SPAN><SPAN class="str">&lt;string&gt;</SPAN><SPAN class="pln"> names</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; names</SPAN><SPAN class="pun">.</SPAN><SPAN class="pln">push_back</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"George"</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; names</SPAN><SPAN class="pun">.</SPAN><SPAN class="pln">push_back</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"John"</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; names</SPAN><SPAN class="pun">.</SPAN><SPAN class="pln">push_back</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Thomas"</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">rolodex</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetNames</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">SetArrayArgument</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">names</SPAN><SPAN class="pun">.</SPAN><SPAN class="kwd">begin</SPAN><SPAN class="pun">(),</SPAN><SPAN class="pln"> names</SPAN><SPAN class="pun">.</SPAN><SPAN class="kwd">end</SPAN><SPAN class="pun">()));</SPAN></PRE></A><H2><A name="Changing_a_Mock_Object&#39;s_Behavior_Based_on_the_State">Changing a Mock Object's Behavior Based on the State</A></H2><A name="Changing_a_Mock_Object&#39;s_Behavior_Based_on_the_State"><P>If you expect a call to change the behavior of a mock object, you can use <TT>::testing::InSequence</TT> to specify different behaviors before and after the call:  </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pln"> seq</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">my_mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsDirty</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">true</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">my_mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Flush</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">my_mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsDirty</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">false</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp; my_mock</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">FlushIfDirty</SPAN><SPAN class="pun">();</SPAN></PRE><P>This makes <TT>my_mock.IsDirty()</TT> return <TT>true</TT> before <TT>my_mock.Flush()</TT> is called and return <TT>false</TT> afterwards.  </P><P>If the behavior change is more complex, you can store the effects in a variable and make a mock method get its return value from that variable:  </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">SaveArg</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>ACTION_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnPointee</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> p</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">p</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> previous_value </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">my_mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">GetPrevValue</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnPointee</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">previous_value</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">my_mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">UpdateValue</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">SaveArg</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(&amp;</SPAN><SPAN class="pln">previous_value</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; my_mock</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoSomethingToUpdateValue</SPAN><SPAN class="pun">();</SPAN></PRE><P>Here <TT>my_mock.GetPrevValue()</TT> will always return the argument of the last <TT>UpdateValue()</TT> call. </P></A><H2><A name="Setting_the_Default_Value_for_a_Return_Type">Setting the Default Value for a Return Type</A></H2><A name="Setting_the_Default_Value_for_a_Return_Type"><P>If a mock method's return type is a built-in C++ type or pointer, by default it will return 0 when invoked. You only need to specify an action if this default value doesn't work for you. </P><P>Sometimes, you may want to change this default value, or you may want to specify a default value for types Google Mock doesn't know about. You can do this using the <TT>::testing::DefaultValue</TT> class template: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">CalculateBar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pln"> default_bar</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Sets the default return value for type Bar.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">DefaultValue</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&gt;::</SPAN><SPAN class="typ">Set</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">default_bar</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// We don't need to specify an action here, as the default</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// return value works for us.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">CalculateBar</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">CalculateBar</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// This should return default_bar.</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Unsets the default return value.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">DefaultValue</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">&gt;::</SPAN><SPAN class="typ">Clear</SPAN><SPAN class="pun">();</SPAN></PRE><P>Please note that changing the default value for a type can make you tests hard to understand. We recommend you to use this feature judiciously. For example, you may want to make sure the <TT>Set()</TT> and <TT>Clear()</TT> calls are right next to the code that uses your mock. </P></A><H2><A name="Setting_the_Default_Actions_for_a_Mock_Method">Setting the Default Actions for a Mock Method</A></H2><A name="Setting_the_Default_Actions_for_a_Mock_Method"><P>You've learned how to change the default value of a given type. However, this may be too coarse for your purpose: perhaps you have two mock methods with the same return type and you want them to have different behaviors. The <TT>ON_CALL()</TT> macro allows you to customize your mock's behavior at the method level: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">AnyNumber</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; ON_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Sign</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(-</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; ON_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Sign</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; ON_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Sign</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Gt</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">)))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillByDefault</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Sign</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">AnyNumber</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Sign</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp; </SPAN><SPAN class="com">// This should return 1.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Sign</SPAN><SPAN class="pun">(-</SPAN><SPAN class="lit">9</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// This should return -1.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Sign</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp; </SPAN><SPAN class="com">// This should return 0.</SPAN></PRE><P>As you may have guessed, when there are more than one <TT>ON_CALL()</TT> statements, the news order take precedence over the older ones. In other words, the <STRONG>last</STRONG> one that matches the function arguments will be used. This matching order allows you to set up the common behavior in a mock object's constructor or the test fixture's set-up phase and specialize the mock's behavior later. </P></A><H2><A name="Using_Functions/Methods/Functors_as_Actions">Using Functions/Methods/Functors as Actions</A></H2><A name="Using_Functions/Methods/Functors_as_Actions"><P>If the built-in actions don't suit you, you can easily use an existing function, method, or functor as an action: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Sum</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">CalculateSum</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> x </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Helper</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Helper</SPAN><SPAN class="pln"> helper</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Sum</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">CalculateSum</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">helper</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="typ">Helper</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Sum</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// Invokes CalculateSum(5, 6).</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">10</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Invokes helper.ComplexJob(10);</SPAN></PRE><P>The only requirement is that the type of the function, etc must be <I>compatible</I> with the signature of the mock function, meaning that the latter's arguments can be implicitly converted to the corresponding arguments of the former, and the former's return type can be implicitly converted to that of the latter. So, you can invoke something whose type is <I>not</I> exactly the same as the mock function, as long as it's safe to do so - nice, huh? </P></A><H2><A name="Invoking_a_Function/Method/Functor_Without_Arguments">Invoking a Function/Method/Functor Without Arguments</A></H2><A name="Invoking_a_Function/Method/Functor_Without_Arguments"><P><TT>Invoke()</TT> is very useful for doing actions that are more complex. It passes the mock function's arguments to the function or functor being invoked such that the callee has the full context of the call to work with. If the invoked function is not interested in some or all of the arguments, it can simply ignore them. </P><P>Yet, a common pattern is that a test author wants to invoke a function without the arguments of the mock function. <TT>Invoke()</TT> allows her to do that using a wrapper function that throws away the arguments before invoking an underlining nullary function. Needless to say, this can be tedious and obscures the intent of the test. </P><P><TT>InvokeWithoutArgs()</TT> solves this problem. It's like <TT>Invoke()</TT> except that it doesn't pass the mock function's arguments to the callee. Here's an example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">InvokeWithoutArgs</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Job1</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">InvokeWithoutArgs</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Job1</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">ComplexJob</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">10</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Invokes Job1().</SPAN></PRE></A><H2><A name="Invoking_an_Argument_of_the_Mock_Function">Invoking an Argument of the Mock Function</A></H2><A name="Invoking_an_Argument_of_the_Mock_Function"><P>Sometimes a mock function will receive a function pointer or a functor (in other words, a "callable") as an argument, e.g. </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">fp</SPAN><SPAN class="pun">)(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>and you may want to invoke this callable argument: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(...);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Will execute (*fp)(5), where fp is the</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// second argument DoThis() receives.</SPAN></PRE><P>Arghh, you need to refer to a mock function argument but C++ has no lambda (yet), so you have to define your own action. :-( Or do you really? </P><P>Well, Google Mock has an action to solve <I>exactly</I> this problem: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">InvokeArgument</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">N</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">arg_1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> arg_2</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> arg_m</SPAN><SPAN class="pun">)</SPAN></PRE><P>will invoke the <TT>N</TT>-th (0-based) argument the mock function receives, with <TT>arg_1</TT>, <TT>arg_2</TT>, ..., and <TT>arg_m</TT>. No matter if the argument is a function pointer or a functor, Google Mock handles them both. </P><P>With that, you could write: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">InvokeArgument</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">InvokeArgument</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Will execute (*fp)(5), where fp is the</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// second argument DoThis() receives.</SPAN></PRE><P>What if the callable takes an argument by reference? No problem - just wrap it inside <TT>ByRef()</TT>: </P><PRE class="prettyprint"><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">fp</SPAN><SPAN class="pun">)(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Helper</SPAN><SPAN class="pun">&amp;)));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ByRef</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">InvokeArgument</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Helper</SPAN><SPAN class="pln"> helper</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">InvokeArgument</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ByRef</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">helper</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// ByRef(helper) guarantees that a reference to helper, not a copy of it,</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// will be passed to the callable.</SPAN></PRE><P>What if the callable takes an argument by reference and we do <STRONG>not</STRONG> wrap the argument in <TT>ByRef()</TT>? Then <TT>InvokeArgument()</TT> will <I>make a copy</I> of the argument, and pass a <I>reference to the copy</I>, instead of a reference to the original value, to the callable. This is especially handy when the argument is a temporary value: </P><PRE class="prettyprint"><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">f</SPAN><SPAN class="pun">)(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> s</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">InvokeArgument</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">InvokeArgument</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="lit">5.0</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"Hi"</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Will execute (*f)(5.0, string("Hi")), where f is the function pointer</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// DoThat() receives. &nbsp;Note that the values 5.0 and string("Hi") are</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// temporary and dead once the EXPECT_CALL() statement finishes. &nbsp;Yet</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// it's fine to perform this action later, since a copy of the values</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// are kept inside the InvokeArgument action.</SPAN></PRE></A><H2><A name="Ignoring_an_Action&#39;s_Result">Ignoring an Action's Result</A></H2><A name="Ignoring_an_Action&#39;s_Result"><P>Sometimes you have an action that returns <I>something</I>, but you need an action that returns <TT>void</TT> (perhaps you want to use it in a mock function that returns <TT>void</TT>, or perhaps it needs to be used in <TT>DoAll()</TT> and it's not the last in the list). <TT>IgnoreResult()</TT> lets you do that. For example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Process</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MyData</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> data</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">string</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoSomething</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD1</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Abc</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MyData</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> data</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Xyz</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Abc</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// .WillOnce(Invoke(Process));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// The above line won't compile as Process() returns int but Abc() needs</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// to return void.</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IgnoreResult</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Process</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Xyz</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoAll</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IgnoreResult</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoSomething</SPAN><SPAN class="pun">)),</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// Ignores the string DoSomething() returns.</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">true</SPAN><SPAN class="pun">)));</SPAN></PRE><P>Note that you <STRONG>cannot</STRONG> use <TT>IgnoreResult()</TT> on an action that already returns <TT>void</TT>. Doing so will lead to ugly compiler errors. </P></A><H2><A name="Selecting_an_Action&#39;s_Arguments">Selecting an Action's Arguments</A></H2><A name="Selecting_an_Action&#39;s_Arguments"><P>Say you have a mock function <TT>Foo()</TT> that takes seven arguments, and you have a custom action that you want to invoke when <TT>Foo()</TT> is called. Trouble is, the custom action only wants three arguments: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD7</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> visible</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> name</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> map</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">pair</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">&gt;,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pun">&gt;&amp;</SPAN><SPAN class="pln"> weight</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> min_weight</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> max_wight</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsVisibleInQuadrant1</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> visible</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> visible </SPAN><SPAN class="pun">&amp;&amp;</SPAN><SPAN class="pln"> x </SPAN><SPAN class="pun">&gt;=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&amp;&amp;</SPAN><SPAN class="pln"> y </SPAN><SPAN class="pun">&gt;=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IsVisibleInQuadrant1</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Uh, won't compile. :-(</SPAN></PRE><P>To please the compiler God, you can to define an "adaptor" that has the same signature as <TT>Foo()</TT> and calls the custom action with the right arguments: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MyIsVisibleInQuadrant1</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> visible</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> name</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> map</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">pair</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">&gt;,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pun">&gt;&amp;</SPAN><SPAN class="pln"> weight</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> min_weight</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> max_wight</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsVisibleInQuadrant1</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">visible</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">MyIsVisibleInQuadrant1</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Now it works.</SPAN></PRE><P>But isn't this awkward? </P><P>Google Mock provides a generic <I>action adaptor</I>, so you can spend your time minding more important business than writing your own adaptors. Here's the syntax: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">WithArgs</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">N1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> N2</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Nk</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">action</SPAN><SPAN class="pun">)</SPAN></PRE><P>creates an action that passes the arguments of the mock function at the given indices (0-based) to the inner <TT>action</TT> and performs it. Using <TT>WithArgs</TT>, our original example can be written as: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">WithArgs</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">WithArgs</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IsVisibleInQuadrant1</SPAN><SPAN class="pun">)));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// No need to define your own adaptor.</SPAN></PRE><P>For better readability, Google Mock also gives you: </P><UL><LI><TT>WithoutArgs(action)</TT> when the inner <TT>action</TT> takes <I>no</I> argument, and  </LI><LI><TT>WithArg&lt;N&gt;(action)</TT> (no <TT>s</TT> after <TT>Arg</TT>) when the inner <TT>action</TT> takes <I>one</I> argument.  </LI></UL><P>As you may have realized, <TT>InvokeWithoutArgs(...)</TT> is just syntactic sugar for <TT>WithoutArgs(Inovke(...))</TT>. </P><P>Here are more tips:   </P><UL><LI>The inner action used in <TT>WithArgs</TT> and friends does not have to be <TT>Invoke()</TT> -- it can be anything.  </LI><LI>You can repeat an argument in the argument list if necessary, e.g. <TT>WithArgs&lt;2, 3, 3, 5&gt;(...)</TT>.  </LI><LI>You can change the order of the arguments, e.g. <TT>WithArgs&lt;3, 2, 1&gt;(...)</TT>.  </LI><LI>The types of the selected arguments do <I>not</I> have to match the signature of the inner action exactly. It works as long as they can be implicitly converted to the corresponding arguments of the inner action. For example, if the 4-th argument of the mock function is an <TT>int</TT> and <TT>my_action</TT> takes a <TT>double</TT>, <TT>WithArg&lt;4&gt;(my_action)</TT> will work.  </LI></UL><P></P></A><H2><A name="Ignoring_Arguments_in_Action_Functions">Ignoring Arguments in Action Functions</A></H2><A name="Ignoring_Arguments_in_Action_Functions"><P>The selecting-an-action's-arguments recipe showed us one way to make a mock function and an action with incompatible argument lists fit together. The downside is that wrapping the action in <TT>WithArgs&lt;...&gt;()</TT> can get tedious for people writing the tests. </P><P>If you are defining a function, method, or functor to be used with <TT>Invoke*()</TT>, and you are not interested in some of its arguments, an alternative to <TT>WithArgs</TT> is to declare the uninteresting arguments as <TT>Unused</TT>. This makes the definition less cluttered and less fragile in case the types of the uninteresting arguments change. It could also increase the chance the action function can be reused. For example, given </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; MOCK_METHOD3</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> label</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD3</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> index</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">));</SPAN></PRE><P>instead of </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DistanceToOriginWithLabel</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> label</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> sqrt</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">x</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">x </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">y</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DistanceToOriginWithIndex</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> index</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> sqrt</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">x</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">x </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">y</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXEPCT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"abc"</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DistanceToOriginWithLabel</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXEPCT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DistanceToOriginWithIndex</SPAN><SPAN class="pun">));</SPAN></PRE><P>you could write  </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Unused</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DistanceToOrigin</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Unused</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> sqrt</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">x</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">x </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">y</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXEPCT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"abc"</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DistanceToOrigin</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXEPCT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Invoke</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DistanceToOrigin</SPAN><SPAN class="pun">));</SPAN></PRE></A><H2><A name="Sharing_Actions">Sharing Actions</A></H2><A name="Sharing_Actions"><P>Just like matchers, a Google Mock action object consists of a pointer to a ref-counted implementation object. Therefore copying actions is also allowed and very efficient. When the last action that references the implementation object dies, the implementation object will be deleted. </P><P>If you have some complex action that you want to use again and again, you may not have to build it from scratch everytime. If the action doesn't have an internal state (i.e. if it always does the same thing no matter how many times it has been called), you can assign it to an action variable and use that variable repeatedly. For example: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Action</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*)&gt;</SPAN><SPAN class="pln"> set_flag </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoAll</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">SetArgumentPointee</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="typ">Return</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">true</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">use</SPAN><SPAN class="pln"> set_flag </SPAN><SPAN class="kwd">in</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">and</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN></PRE><P>However, if the action has its own state, you may be surprised if you share the action object. Suppose you have an action factory <TT>IncrementCounter(init)</TT> which creates an action that increments and returns a counter whose initial value is <TT>init</TT>, using two actions created from the same expression and using a shared action will exihibit different behaviors. Example: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IncrementCounter</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IncrementCounter</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Returns 1.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Returns 2.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Returns 1 - Blah() uses a different</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="com">// counter than Bar()'s.</SPAN></PRE><P>versus  </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Action</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">()&gt;</SPAN><SPAN class="pln"> increment </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IncrementCounter</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">increment</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">())</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillRepeatedly</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">increment</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Returns 1.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Returns 2.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Returns 3 - the counter is shared.</SPAN></PRE></A><H1><A name="Misc_Recipes_on_Using_Google_Mock">Misc Recipes on Using Google Mock</A></H1><A name="Misc_Recipes_on_Using_Google_Mock"></A><H2><A name="Forcing_a_Verification">Forcing a Verification</A></H2><A name="Forcing_a_Verification"></A><P><A name="Forcing_a_Verification">When it's being destoyed, your friendly mock object will automatically verify that all expectations on it have been satisfied, and will generate </A><A href="http://code.google.com/p/googletest/" rel="nofollow">Google Test</A> failures if not. This is convenient as it leaves you with one less thing to worry about. That is, unless you are not sure if your mock object will be destoyed. </P><P>How could it be that your mock object won't eventually be destroyed? Well, it might be created on the heap and owned by the code you are testing. Suppose there's a bug in that code and it doesn't delete the mock object properly - you could end up with a passing test when there's actually a bug. </P><P>Using a heap checker is a good idea and can alleviate the concern, but its implementation may not be 100% reliable. So, sometimes you do want to <I>force</I> Google Mock to verify a mock object before it is (hopefully) destructed. You can do this with <TT>Mock::VerifyAndClearExpectations(&amp;mock_object)</TT>: </P><PRE class="prettyprint"><SPAN class="pln">TEST</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">MyServerTest</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ProcessesRequest</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Mock</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> foo </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...)...;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// ... other expectations ...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// server now owns foo.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MyServer</SPAN><SPAN class="pln"> server</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; server</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">ProcessRequest</SPAN><SPAN class="pun">(...);</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// In case that server's destructor will forget to delete foo,</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// this will verify the expectations anyway.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Mock</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">VerifyAndClearExpectations</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// server is destroyed when it goes out of scope here.</SPAN></PRE><P><STRONG>Tip:</STRONG> The <TT>Mock::VerifyAndClearExpectations()</TT> function returns a <TT>bool</TT> to indicate whether the verification was successful (<TT>true</TT> for yes), so you can wrap that function call inside a <TT>ASSERT_TRUE()</TT> if there is no point going further when the verification has failed. </P><H2><A name="Using_Check_Points">Using Check Points</A></H2><A name="Using_Check_Points"><P>Sometimes you may want to "reset" a mock object at various check points in your test: at each check point, you verify that all existing expectations on the mock object have been satisfied, and then you set some new expectations on it as if it's newly created. This allows you to work with a mock object in "phases" whose sizes are each manageable. </P><P>One such scenario is that in your test's <TT>SetUp()</TT> function, you may want to put the object you are testing into a certain state, with the help from a mock object. Once in the desired state, you want to clear all expectations on the mock, such that in the <TT>TEST_F</TT> body you can set fresh expectations on it. </P><P>As you may have figured out, the <TT>Mock::VerifyAndClearExpectations()</TT> function we saw in the previous recipe can help you here. Or, if you are using <TT>ON_CALL()</TT> to set default actions on the mock object and want to clear the default actions as well, use <TT>Mock::VerifyAndClear(&amp;mock_object)</TT> instead. This function does what <TT>Mock::VerifyAndClearExpectations(&amp;mock_object)</TT> does and returns the same <TT>bool</TT>, <STRONG>plus</STRONG> it clears the <TT>ON_CALL()</TT> statements on <TT>mock_object</TT> too. </P><P>Another trick you can use to achieve the same effect is to put the expectations in sequences and insert calls to a dummy "check-point" function at specific places. Then you can verify that the mock function calls do happen at the right time. For example, if you are exercising code: </P><PRE class="prettyprint"><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">);</SPAN></PRE><P>and want to verify that <TT>Foo(1)</TT> and <TT>Foo(3)</TT> both invoke <TT>mock.Bar("a")</TT>, but <TT>Foo(2)</TT> doesn't invoke anything. You can write: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MockFunction</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>TEST</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">FooTest</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">InvokesBarCorrectly</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MyMock</SPAN><SPAN class="pln"> mock</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Class MockFunction&lt;F&gt; has exactly one mock method. &nbsp;It is named</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Call() and has type F.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MockFunction</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">string</SPAN><SPAN class="pln"> check_point_name</SPAN><SPAN class="pun">)&gt;</SPAN><SPAN class="pln"> check</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pln"> s</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"a"</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">check</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Call</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"1"</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">check</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Call</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"2"</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"a"</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; check</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Call</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"1"</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; check</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Call</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"2"</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>The expectation spec says that the first <TT>Bar("a")</TT> must happen before check point "1", the second <TT>Bar("a")</TT> must happen after check point "2", and nothing should happen between the two check points. The explicit check points make it easy to tell which <TT>Bar("a")</TT> is called by which call to <TT>Foo()</TT>. </P></A><H2><A name="Mocking_Destructors">Mocking Destructors</A></H2><A name="Mocking_Destructors"><P>Sometimes you want to make sure a mock object is destructed at the right time, e.g. after <TT>bar-&gt;A()</TT> is called but before <TT>bar-&gt;B()</TT> is called. We already know that you can specify constraints on the order of mock function calls, so all we need to do is to mock the destructor of the mock function. </P><P>This sounds simple, except for one problem: a destructor is a special function with special syntax and special semantics, and the <TT>MOCK_METHOD0</TT> macro doesn't work for it: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(~</SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Won't compile!</SPAN></PRE><P>The good news is that you can use a simple pattern to achieve the same effect. First, add a mock function <TT>Die()</TT> to your mock class and call it in the destructor, like this: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Add the following two lines to the mock class.</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD0</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Die</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Die</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>(If the name <TT>Die()</TT> clashes with an existing symbol, choose another name.) Now, we have translated the problem of testing when a <TT>MockFoo</TT> object dies to testing when its <TT>Die()</TT> method is called: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> foo </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MockBar</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> bar </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockBar</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">InSequence</SPAN><SPAN class="pln"> s</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; &nbsp; </SPAN><SPAN class="com">// Expects *foo to die after bar-&gt;A() and before bar-&gt;B().</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> A</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Die</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> B</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN></PRE><P>And that's that. </P></A><H2><A name="Using_Google_Mock_and_Threads">Using Google Mock and Threads</A></H2><A name="Using_Google_Mock_and_Threads"><P><STRONG>IMPORTANT NOTE:</STRONG> What we describe in this recipe is <STRONG>ONLY</STRONG> true on platforms where Google Mock is thread-safe. Currently these are only platforms that support the pthreads library (this includes Linux and Mac). To make it thread-safe on other platforms we only need to implement some synchronization operations in <TT>&lt;gtest/internal/gtest-port.h&gt;</TT>. </P><P>In a <STRONG>unit</STRONG> test, it's best if you could isolate and test a piece of code in a single-threaded context. That avoids race conditions and dead locks, and makes debugging your test much easier. </P><P>Yet many programs are multi-threaded, and sometimes to test something we need to pound on it from more than one thread. Google Mock works for this purpose too. </P><P>Remember the steps for using a mock:   </P><OL><LI>Create a mock object <TT>foo</TT>.  </LI><LI>Set its default actions and expectations using <TT>ON_CALL()</TT> and <TT>EXPECT_CALL()</TT>.  </LI><LI>The code under test calls methods of <TT>foo</TT>.  </LI><LI>Optionally, verify and reset the mock.  </LI><LI>Destroy the mock yourself, or let the code under test destroy it. The destructor will automatically verify it.  </LI></OL><P></P><P>If you follow the following simple rules, your mocks and threads can live happily togeter:   </P><UL><LI>Execute your <I>test code</I> (as opposed to the code being tested) in <I>one</I> thread. This makes your test easy to follow.  </LI><LI>Obviously, you can do step #1 without locking.  </LI><LI>When doing step #2 and #5, make sure no other thread is accessing <TT>foo</TT>. Obvious too, huh?  </LI><LI>#3 and #4 can be done either in one thread or in multiple threads - anyway you want. Google Mock takes care of the locking, so you don't have to do any - unless required by your test logic.  </LI></UL><P></P><P>If you violate the rules (for example, if you set expectations on a mock while another thread is calling its methods), you get undefined behavior. That's not fun, so don't do it. </P><P>Google Mock guarantees that the action for a mock function is done in the same thread that called the mock function. For example, in </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">action1</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">action2</SPAN><SPAN class="pun">);</SPAN></PRE><P>if <TT>Foo(1)</TT> is called in thread 1 and <TT>Foo(2)</TT> is called in thread 2, Google Mock will execute <TT>action1</TT> in thread 1 and <TT>action2</TT> in thread 2. </P><P>Google Mock does <I>not</I> impose a sequence on actions performed in different threads (doing so may create deadlocks as the actions may need to cooperate). This means that the execution of <TT>action1</TT> and <TT>action2</TT> in the above example <I>may</I> interleave. If this is a problem, you should add proper synchronization logic to <TT>action1</TT> and <TT>action2</TT> to make the test thread-safe. </P><P>Also, remember that <TT>DefaultValue&lt;T&gt;</TT> is a global resource that potentially affects <I>all</I> living mock objects in your program. Naturally, you won't want to mess with it from multiple threads or when there still are mocks in action. </P></A><H2><A name="Controlling_How_Much_Information_Google_Mock_Prints">Controlling How Much Information Google Mock Prints</A></H2><A name="Controlling_How_Much_Information_Google_Mock_Prints"><P>When Google Mock sees something that has the potential of being an error (e.g. a mock function with no expectation is called, a.k.a. an uninteresting call, which is allowed but perhaps you forgot to explicitly ban the call), it prints some warning messages, including the arguments of the function and the return value. Hopefully this will remind you to take a look and see if there is indeed a problem. </P><P>Sometimes you are confident that your tests are correct and may not appreciate such friendly messages. Some other times, you are debugging your tests or learning about the behavior of the code you are testing, and wish you could observe every mock call that happens (including argument values and the return value). Clearly, one size doesn't fit all. </P><P>You can control how much Google Mock tells you using the <TT>--gmock_verbose=LEVEL</TT> command-line flag, where <TT>LEVEL</TT> is a string with three possible values: </P><UL><LI><TT>info</TT>: Google Mock will print all informational messages, warnings, and errors (most verbose). At this setting, Google Mock will also log any calls to the <TT>ON_CALL/EXPECT_CALL</TT> macros.  </LI><LI><TT>warning</TT>: Google Mock will print both warnings and errors (less verbose). This is the default.  </LI><LI><TT>error</TT>: Google Mock will print errors only (least verbose).  </LI></UL><P>Alternatively, you can adjust the value of that flag from within your tests like so: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">FLAGS_gmock_verbose </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"error"</SPAN><SPAN class="pun">;</SPAN></PRE><P>Now, judiciously use the right flag to enable Google Mock serve you better! </P></A><H2><A name="Running_Tests_in_Emacs">Running Tests in Emacs</A></H2><A name="Running_Tests_in_Emacs"></A><P><A name="Running_Tests_in_Emacs">If you build and run your tests in Emacs, the source file locations of Google Mock and </A><A href="http://code.google.com/p/googletest/" rel="nofollow">Google Test</A> errors will be highlighted. Just press <TT>&lt;Enter&gt;</TT> on one of them and you'll be taken to the offending line. Or, you can just type <TT>C-x </TT>` to jump to the next error. </P><P>To make it even easier, you can add the following lines to your <TT>~/.emacs</TT> file: </P><PRE class="prettyprint"><SPAN class="pun">(</SPAN><SPAN class="kwd">global</SPAN><SPAN class="pun">-</SPAN><SPAN class="kwd">set</SPAN><SPAN class="pun">-</SPAN><SPAN class="pln">key </SPAN><SPAN class="str">"\M-m"</SPAN><SPAN class="pln"> &nbsp; </SPAN><SPAN class="str">'compile) &nbsp;; m is for make<BR>(global-set-key [M-down] '</SPAN><SPAN class="kwd">next</SPAN><SPAN class="pun">-</SPAN><SPAN class="pln">error</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">global</SPAN><SPAN class="pun">-</SPAN><SPAN class="kwd">set</SPAN><SPAN class="pun">-</SPAN><SPAN class="pln">key </SPAN><SPAN class="pun">[</SPAN><SPAN class="pln">M</SPAN><SPAN class="pun">-</SPAN><SPAN class="pln">up</SPAN><SPAN class="pun">]</SPAN><SPAN class="pln"> &nbsp; </SPAN><SPAN class="str">'(lambda () (interactive) (next-error -1)))</SPAN></PRE><P>Then you can type <TT>M-m</TT> to start a build, or <TT>M-up</TT>/<TT>M-down</TT> to move back and forth between errors. </P><H2><A name="Fusing_Google_Mock_Source_Files">Fusing Google Mock Source Files</A></H2><A name="Fusing_Google_Mock_Source_Files"><P>Google Mock's implementation consists of dozens of files (excluding its own tests).  Sometimes you may want them to be packaged up in fewer files instead, such that you can easily copy them to a new machine and start hacking there.  For this we provide an experimental Python script <TT>fuse_gmock_files.py</TT> in the <TT>scripts/</TT> directory (starting with release 1.2.0).  Assuming you have Python 2.4 or above installed on your machine, just go to that directory and run </P><PRE class="prettyprint"><SPAN class="pln">python fuse_gmock_files</SPAN><SPAN class="pun">.</SPAN><SPAN class="pln">py OUTPUT_DIR</SPAN></PRE></A><P><A name="Fusing_Google_Mock_Source_Files">and you should see an <TT>OUTPUT_DIR</TT> directory being created with files <TT>gtest/gtest.h</TT>, <TT>gmock/gmock.h</TT>, and <TT>gmock-gtest-all.cc</TT> in it. These three files contain everything you need to use Google Mock (and Google Test).  Just copy them to anywhere you want and you are ready to write tests and use mocks.  You can use the </A><A href="http://code.google.com/p/googlemock/source/browse/trunk/scripts/test/Makefile" rel="nofollow">scrpts/test/Makefile</A> file as an example on how to compile your tests against them. </P><H1><A name="Extending_Google_Mock">Extending Google Mock</A></H1><A name="Extending_Google_Mock"></A><H2><A name="Writing_New_Matchers_Quickly">Writing New Matchers Quickly</A></H2><A name="Writing_New_Matchers_Quickly"><P>The <TT>MATCHER*</TT> family of macros can be used to define custom matchers easily.  The syntax: </P><PRE class="prettyprint"><SPAN class="pln">MATCHER</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">name</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"description string"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> statements</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>will define a matcher with the given name that executes the statements, which must return a <TT>bool</TT> to indicate if the match succeeds.  Inside the statements, you can refer to the value being matched by <TT>arg</TT>, and refer to its type by <TT>arg_type</TT>. </P><P>The description string documents what the matcher does, and is used to generate the failure message when the match fails.  Since a <TT>MATCHER()</TT> is usually defined in a header file shared by multiple C++ source files, we require the description to be a C-string <I>literal</I> to avoid possible side effects.  It can be empty (<TT>""</TT>), in which case Google Mock will use the sequence of words in the matcher name as the description. </P><P>For example: </P><PRE class="prettyprint"><SPAN class="pln">MATCHER</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IsDivisibleBy7</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">""</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">arg </SPAN><SPAN class="pun">%</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>allows you to write </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="com">// Expects mock_foo.Bar(n) to be called where n is divisible by 7.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock_foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IsDivisibleBy7</SPAN><SPAN class="pun">()));</SPAN></PRE><P>or, </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="com">// Verifies that the value of some_expression is divisible by 7.</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">some_expression</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsDivisibleBy7</SPAN><SPAN class="pun">());</SPAN></PRE><P>If the above assertion fails, it will print something like: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Value</SPAN><SPAN class="pln"> of</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> some_expression<BR>&nbsp; </SPAN><SPAN class="typ">Expected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">is</SPAN><SPAN class="pln"> divisible </SPAN><SPAN class="kwd">by</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">Actual</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">27</SPAN></PRE><P>where the description <TT>"is divisible by 7"</TT> is automatically calculated from the matcher name <TT>IsDivisibleBy7</TT>. </P><P>Optionally, you can stream additional information to a hidden argument named <TT>result_listener</TT> to explain the match result. For example, a better definition of <TT>IsDivisibleBy7</TT> is: </P><PRE class="prettyprint"><SPAN class="pln">MATCHER</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IsDivisibleBy7</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">""</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">if</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">((</SPAN><SPAN class="pln">arg </SPAN><SPAN class="pun">%</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">true</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">result_listener </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"the remainder is "</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">arg </SPAN><SPAN class="pun">%</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">false</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>With this definition, the above assertion will give a better message: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Value</SPAN><SPAN class="pln"> of</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> some_expression<BR>&nbsp; </SPAN><SPAN class="typ">Expected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">is</SPAN><SPAN class="pln"> divisible </SPAN><SPAN class="kwd">by</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">Actual</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">27</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">the remainder </SPAN><SPAN class="kwd">is</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">)</SPAN></PRE><P>You should let <TT>MatchAndExplain()</TT> print <I>any additional information</I> that can help a user understand the match result. Note that it should explain why the match succeeds in case of a success (unless it's obvious) - this is useful when the matcher is used inside <TT>Not()</TT>. There is no need to print the argument value itself, as Google Mock already prints it for you. </P><P><STRONG>Notes:</STRONG> </P><OL><LI>The type of the value being matched (<TT>arg_type</TT>) is determined by the context in which you use the matcher and is supplied to you by the compiler, so you don't need to worry about declaring it (nor can you).  This allows the matcher to be polymorphic.  For example, <TT>IsDivisibleBy7()</TT> can be used to match any type where the value of <TT>(arg % 7) == 0</TT> can be implicitly converted to a <TT>bool</TT>.  In the <TT>Bar(IsDivisibleBy7())</TT> example above, if method <TT>Bar()</TT> takes an <TT>int</TT>, <TT>arg_type</TT> will be <TT>int</TT>; if it takes an <TT>unsigned long</TT>, <TT>arg_type</TT> will be <TT>unsigned long</TT>; and so on. </LI><LI>Google Mock doesn't guarantee when or how many times a matcher will be invoked. Therefore the matcher logic must be <I>purely functional</I> (i.e. it cannot have any side effect, and the result must not depend on anything other than the value being matched and the matcher parameters). This requirement must be satisfied no matter how you define the matcher (e.g. using one of the methods described in the following recipes). In particular, a matcher can never call a mock function, as that will affect the state of the mock object and Google Mock.  </LI></OL></A><H2><A name="Writing_New_Parameterized_Matchers_Quickly">Writing New Parameterized Matchers Quickly</A></H2><A name="Writing_New_Parameterized_Matchers_Quickly"><P>Sometimes you'll want to define a matcher that has parameters.  For that you can use the macro: </P><PRE class="prettyprint"><SPAN class="pln">MATCHER_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">name</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> param_name</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"description string"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> statements</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>For example: </P><PRE class="prettyprint"><SPAN class="pln">MATCHER_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">HasAbsoluteValue</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> value</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">""</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> abs</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">arg</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> value</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>will allow you to write: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; EXPECT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Blah</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"a"</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">HasAbsoluteValue</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">n</SPAN><SPAN class="pun">));</SPAN></PRE><P>which may lead to this message (assuming <TT>n</TT> is 10): </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Value</SPAN><SPAN class="pln"> of</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Blah</SPAN><SPAN class="pun">(</SPAN><SPAN class="str">"a"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Expected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> has absolute value </SPAN><SPAN class="lit">10</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="typ">Actual</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">-</SPAN><SPAN class="lit">9</SPAN></PRE><P>Note that both the matcher description and its parameter are printed, making the message human-friendly. </P><P>In the matcher definition body, you can write <TT>foo_type</TT> to reference the type of a parameter named <TT>foo</TT>.  For example, in the body of <TT>MATCHER_P(HasAbsoluteValue, value)</TT> above, you can write <TT>value_type</TT> to refer to the type of <TT>value</TT>. </P><P>Google Mock also provides <TT>MATCHER_P2</TT>, <TT>MATCHER_P3</TT>, ..., up to <TT>MATCHER_P10</TT> to support multi-parameter matchers: </P><PRE class="prettyprint"><SPAN class="pln">MATCHER_Pk</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">name</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> param_1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> param_k</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"description string"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> statements</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>Please note that the custom description string is for a particular <STRONG>instance</STRONG> of the matcher, where the parameters have been bound to actual values.  Therefore usually you'll want the parameter values to be part of the description.  Google Mock lets you do that using Python-style interpolations.  The following syntaxes are supported currently: </P><P></P><TABLE><TBODY><TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>%%</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> a single <TT>%</TT> character </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>%(*)s</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> all parameters of the matcher printed as a tuple </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>%(foo)s</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> value of the matcher parameter named <TT>foo</TT> </TD></TR> </TBODY></TABLE><P></P><P>For example, </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; MATCHER_P2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">InClosedRange</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> low</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> hi</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"is in range [%(low)s, %(hi)s]"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> low </SPAN><SPAN class="pun">&lt;=</SPAN><SPAN class="pln"> arg </SPAN><SPAN class="pun">&amp;&amp;</SPAN><SPAN class="pln"> arg </SPAN><SPAN class="pun">&lt;=</SPAN><SPAN class="pln"> hi</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">InClosedRange</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">4</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">));</SPAN></PRE><P>would generate a failure that contains the message: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Expected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">is</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">in</SPAN><SPAN class="pln"> range </SPAN><SPAN class="pun">[</SPAN><SPAN class="lit">4</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">]</SPAN></PRE><P>If you specify <TT>""</TT> as the description, the failure message will contain the sequence of words in the matcher name followed by the parameter values printed as a tuple.  For example, </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; MATCHER_P2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">InClosedRange</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> low</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> hi</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">""</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_THAT</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">InClosedRange</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">4</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">));</SPAN></PRE><P>would generate a failure that contains the text: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">Expected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">in</SPAN><SPAN class="pln"> closed range </SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">4</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">6</SPAN><SPAN class="pun">)</SPAN></PRE><P>For the purpose of typing, you can view </P><PRE class="prettyprint"><SPAN class="pln">MATCHER_Pk</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> p1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> pk</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"description string"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>as shorthand for </P><PRE class="prettyprint"><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> p1_type</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> pk_type</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="typ">FooMatcherPk</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">p1_type</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> pk_type</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">p1_type p1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> pk_type pk</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>When you write <TT>Foo(v1, ..., vk)</TT>, the compiler infers the types of the parameters <TT>v1</TT>, ..., and <TT>vk</TT> for you.  If you are not happy with the result of the type inference, you can specify the types by explicitly instantiating the template, as in <TT>Foo&lt;long, bool&gt;(5, false)</TT>. As said earlier, you don't get to (or need to) specify <TT>arg_type</TT> as that's determined by the context in which the matcher is used. </P><P>You can assign the result of expression <TT>Foo(p1, ..., pk)</TT> to a variable of type <TT>FooMatcherPk&lt;p1_type, ..., pk_type&gt;</TT>.  This can be useful when composing matchers.  Matchers that don't have a parameter or have only one parameter have special types: you can assign <TT>Foo()</TT> to a <TT>FooMatcher</TT>-typed variable, and assign <TT>Foo(p)</TT> to a <TT>FooMatcherP&lt;p_type&gt;</TT>-typed variable. </P><P>While you can instantiate a matcher template with reference types, passing the parameters by pointer usually makes your code more readable.  If, however, you still want to pass a parameter by reference, be aware that in the failure message generated by the matcher you will see the value of the referenced object but not its address. </P><P>You can overload matchers with different numbers of parameters: </P><PRE class="prettyprint"><SPAN class="pln">MATCHER_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Blah</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> a</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"description string 1"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>MATCHER_P2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Blah</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> a</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> b</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"description string 2"</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>While it's tempting to always use the <TT>MATCHER*</TT> macros when defining a new matcher, you should also consider implementing <TT>MatcherInterface</TT> or using <TT>MakePolymorphicMatcher()</TT> instead (see the recipes that follow), especially if you need to use the matcher a lot.  While these approaches require more work, they give you more control on the types of the value being matched and the matcher parameters, which in general leads to better compiler error messages that pay off in the long run.  They also allow overloading matchers based on parameter types (as opposed to just based on the number of parameters). </P></A><H2><A name="Writing_New_Monomorphic_Matchers">Writing New Monomorphic Matchers</A></H2><A name="Writing_New_Monomorphic_Matchers"><P>A matcher of argument type <TT>T</TT> implements <TT>::testing::MatcherInterface&lt;T&gt;</TT> and does two things: it tests whether a value of type <TT>T</TT> matches the matcher, and can describe what kind of values it matches. The latter ability is used for generating readable error messages when expectations are violated. </P><P>The interface looks like this: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Streams x to the underlying ostream; does nothing if the ostream</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// is NULL.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> T</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">operator</SPAN><SPAN class="pun">&lt;&lt;(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> T</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Returns the underlying ostream.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> stream</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> T</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatcherInterface</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">MatcherInterface</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Returns true iff the matcher matches x; also explains the match</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// result to 'listener'.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchAndExplain</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">T x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> listener</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Describes this matcher to an ostream.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Describes the negation of this matcher to an ostream.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeNegationTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>If you need a custom matcher but <TT>Truly()</TT> is not a good option (for example, you may not be happy with the way <TT>Truly(predicate)</TT> describes itself, or you may want your matcher to be polymorphic as <TT>Eq(value)</TT> is), you can define a matcher to do whatever you want in two steps: first implement the matcher interface, and then define a factory function to create a matcher instance. The second step is not strictly needed but it makes the syntax of using the matcher nicer. </P><P>For example, you can define a matcher to test whether an <TT>int</TT> is divisible by 7 and then use it like this: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MakeMatcher</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Matcher</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MatcherInterface</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DivisibleBy7Matcher</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatcherInterface</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchAndExplain</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> listener</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">n </SPAN><SPAN class="pun">%</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"is divisible by 7"</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeNegationTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"is not divisible by 7"</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">inline</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Matcher</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DivisibleBy7</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MakeMatcher</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DivisibleBy7Matcher</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DivisibleBy7</SPAN><SPAN class="pun">()));</SPAN></PRE><P>You may improve the matcher message by streaming additional information to the <TT>listener</TT> argument in <TT>MatchAndExplain()</TT>: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DivisibleBy7Matcher</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatcherInterface</SPAN><SPAN class="str">&lt;int&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchAndExplain</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> listener</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> remainder </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> n </SPAN><SPAN class="pun">%</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">if</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">remainder </SPAN><SPAN class="pun">!=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">listener </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"the remainder is "</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> remainder</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> remainder </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>Then, <TT>EXPECT_THAT(x, DivisibleBy7());</TT> may general a message like this: </P><PRE class="prettyprint"><SPAN class="typ">Value</SPAN><SPAN class="pln"> of</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> x<BR></SPAN><SPAN class="typ">Expected</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">is</SPAN><SPAN class="pln"> divisible </SPAN><SPAN class="kwd">by</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">7</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Actual</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">23</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">the remainder </SPAN><SPAN class="kwd">is</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">)</SPAN></PRE></A><H2><A name="Writing_New_Polymorphic_Matchers">Writing New Polymorphic Matchers</A></H2><A name="Writing_New_Polymorphic_Matchers"><P>You've learned how to write your own matchers in the previous recipe. Just one problem: a matcher created using <TT>MakeMatcher()</TT> only works for one particular type of arguments. If you want a <I>polymorphic</I> matcher that works with arguments of several types (for instance, <TT>Eq(x)</TT> can be used to match a <TT>value</TT> as long as <TT>value</TT> == <TT>x</TT> compiles -- <TT>value</TT> and <TT>x</TT> don't have to share the same type), you can learn the trick from <TT>&lt;gmock/gmock-matchers.h&gt;</TT> but it's a bit involved. </P><P>Fortunately, most of the time you can define a polymorphic matcher easily with the help of <TT>MakePolymorphicMatcher()</TT>. Here's how you can define <TT>NotNull()</TT> as an example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MakePolymorphicMatcher</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">PolymorphicMatcher</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">NotNullMatcher</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// To implement a polymorphic matcher, first define a COPYABLE class</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// that has three members MatchAndExplain(), DescribeTo(), and</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// DescribeNegationTo(), like the following.</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// In this example, we want to use NotNull() with any pointer, so</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// MatchAndExplain() accepts a pointer of any type as its first argument.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// In general, you can define MatchAndExplain() as an ordinary method or</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// a method template, or even overload it.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> T</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MatchAndExplain</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">T</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> p</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="typ">MatchResultListener</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> </SPAN><SPAN class="com">/* listener */</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> p </SPAN><SPAN class="pun">!=</SPAN><SPAN class="pln"> NULL</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Describes the property of a value matching this matcher.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"is not NULL"</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Describes the property of a value NOT matching this matcher.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeNegationTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"is NULL"</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="com">// To construct a polymorphic matcher, pass an instance of the class</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="com">// to MakePolymorphicMatcher(). &nbsp;Note the return type.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">inline</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">PolymorphicMatcher</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">NotNullMatcher</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MakePolymorphicMatcher</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">NotNullMatcher</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">NotNull</SPAN><SPAN class="pun">()));</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// The argument must be a non-NULL pointer.</SPAN></PRE><P><STRONG>Note:</STRONG> Your polymorphic matcher class does <STRONG>not</STRONG> need to inherit from <TT>MatcherInterface</TT> or any other class, and its methods do <STRONG>not</STRONG> need to be virtual. </P><P>Like in a monomorphic matcher, you may explain the match result by streaming additional information to the <TT>listener</TT> argument in <TT>MatchAndExplain()</TT>. </P></A><H2><A name="Writing_New_Cardinalities">Writing New Cardinalities</A></H2><A name="Writing_New_Cardinalities"><P>A cardinality is used in <TT>Times()</TT> to tell Google Mock how many times you expect a call to occur. It doesn't have to be exact. For example, you can say <TT>AtLeast(5)</TT> or <TT>Between(2, 4)</TT>. </P><P>If the built-in set of cardinalities doesn't suit you, you are free to define your own by implementing the following interface (in namespace <TT>testing</TT>): </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">CardinalityInterface</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">CardinalityInterface</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Returns true iff call_count calls will satisfy this cardinality.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsSatisfiedByCallCount</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> call_count</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Returns true iff call_count calls will saturate this cardinality.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsSaturatedByCallCount</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> call_count</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Describes self to an ostream.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>For example, to specify that a call must occur even number of times, you can write </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Cardinality</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">CardinalityInterface</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MakeCardinality</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">EvenNumberCardinality</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">CardinalityInterface</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsSatisfiedByCallCount</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> call_count</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">call_count </SPAN><SPAN class="pun">%</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">2</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">==</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IsSaturatedByCallCount</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> call_count</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">false</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DescribeTo</SPAN><SPAN class="pun">(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"called even number of times"</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="typ">Cardinality</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">EvenNumber</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MakeCardinality</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">EvenNumberCardinality</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">3</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Times</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">EvenNumber</SPAN><SPAN class="pun">());</SPAN></PRE></A><H2><A name="Writing_New_Actions_Quickly">Writing New Actions Quickly</A></H2><A name="Writing_New_Actions_Quickly"><P>If the built-in actions don't work for you, and you find it inconvenient to use <TT>Invoke()</TT>, you can use a macro from the <TT>ACTION*</TT> family to quickly define a new action that can be used in your code as if it's a built-in action. </P><P>By writing </P><PRE class="prettyprint"><SPAN class="pln">ACTION</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">name</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> statements</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>in a namespace scope (i.e. not inside a class or function), you will define an action with the given name that executes the statements. The value returned by <TT>statements</TT> will be used as the return value of the action.  Inside the statements, you can refer to the K-th (0-based) argument of the mock function as <TT>argK</TT>.  For example: </P><PRE class="prettyprint"><SPAN class="pln">ACTION</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IncrementArg1</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">++(*</SPAN><SPAN class="pln">arg1</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>allows you to write </P><PRE class="prettyprint"><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IncrementArg1</SPAN><SPAN class="pun">());</SPAN></PRE><P>Note that you don't need to specify the types of the mock function arguments.  Rest assured that your code is type-safe though: you'll get a compiler error if <TT>*arg1</TT> doesn't support the <TT>++</TT> operator, or if the type of <TT>++(*arg1)</TT> isn't compatible with the mock function's return type. </P><P>Another example: </P><PRE class="prettyprint"><SPAN class="pln">ACTION</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">(*</SPAN><SPAN class="pln">arg2</SPAN><SPAN class="pun">)(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Blah</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">arg1 </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> arg0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>defines an action <TT>Foo()</TT> that invokes argument #2 (a function pointer) with 5, calls function <TT>Blah()</TT>, sets the value pointed to by argument #1 to 0, and returns argument #0. </P><P>For more convenience and flexibility, you can also use the following pre-defined symbols in the body of <TT>ACTION</TT>: </P><P></P><TABLE><TBODY><TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>argK_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> The type of the K-th (0-based) argument of the mock function </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>args</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> All arguments of the mock function as a tuple </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>args_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> The type of all arguments of the mock function as a tuple </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>return_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> The return type of the mock function </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>function_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> The type of the mock function </TD></TR> </TBODY></TABLE><P></P><P>For example, when using an <TT>ACTION</TT> as a stub action for mock function: </P><PRE class="prettyprint"><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoSomething</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> flag</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> ptr</SPAN><SPAN class="pun">);</SPAN></PRE><P>we have: </P><TABLE><TBODY><TR><TD style="border: 1px solid #aaa; padding: 5px;"> <STRONG>Pre-defined Symbol</STRONG> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <STRONG>Is Bound To</STRONG> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>arg0</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the value of <TT>flag</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>arg0_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the type <TT>bool</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>arg1</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the value of <TT>ptr</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>arg1_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the type <TT>int*</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>args</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the tuple <TT>(flag, ptr)</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>args_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the type <TT>std::tr1::tuple&lt;bool, int*&gt;</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>return_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the type <TT>int</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>function_type</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> the type <TT>int(bool, int*)</TT> </TD></TR> </TBODY></TABLE><P></P></A><H2><A name="Writing_New_Parameterized_Actions_Quickly">Writing New Parameterized Actions Quickly</A></H2><A name="Writing_New_Parameterized_Actions_Quickly"><P>Sometimes you'll want to parameterize an action you define.  For that we have another macro </P><PRE class="prettyprint"><SPAN class="pln">ACTION_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">name</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> param</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> statements</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>For example, </P><PRE class="prettyprint"><SPAN class="pln">ACTION_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> arg0 </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>will allow you to write </P><PRE class="prettyprint"><SPAN class="com">// Returns argument #0 + 5.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Add</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">));</SPAN></PRE><P>For convenience, we use the term <I>arguments</I> for the values used to invoke the mock function, and the term <I>parameters</I> for the values used to instantiate an action. </P><P>Note that you don't need to provide the type of the parameter either. Suppose the parameter is named <TT>param</TT>, you can also use the Google-Mock-defined symbol <TT>param_type</TT> to refer to the type of the parameter as inferred by the compiler.  For example, in the body of <TT>ACTION_P(Add, n)</TT> above, you can write <TT>n_type</TT> for the type of <TT>n</TT>. </P><P>Google Mock also provides <TT>ACTION_P2</TT>, <TT>ACTION_P3</TT>, and etc to support multi-parameter actions.  For example, </P><PRE class="prettyprint"><SPAN class="pln">ACTION_P2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnDistanceTo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> dx </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> arg0 </SPAN><SPAN class="pun">-</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">double</SPAN><SPAN class="pln"> dy </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> arg1 </SPAN><SPAN class="pun">-</SPAN><SPAN class="pln"> y</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> sqrt</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">dx</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">dx </SPAN><SPAN class="pun">+</SPAN><SPAN class="pln"> dy</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">dy</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>lets you write </P><PRE class="prettyprint"><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnDistanceTo</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">5.0</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">26.5</SPAN><SPAN class="pun">));</SPAN></PRE><P>You can view <TT>ACTION</TT> as a degenerated parameterized action where the number of parameters is 0. </P><P>You can also easily define actions overloaded on the number of parameters: </P><PRE class="prettyprint"><SPAN class="pln">ACTION_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Plus</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> a</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR>ACTION_P2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Plus</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> a</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> b</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE></A><H2><A name="Restricting_the_Type_of_an_Argument_or_Parameter_in_an_ACTION">Restricting the Type of an Argument or Parameter in an ACTION</A></H2><A name="Restricting_the_Type_of_an_Argument_or_Parameter_in_an_ACTION"><P>For maximum brevity and reusability, the <TT>ACTION*</TT> macros don't ask you to provide the types of the mock function arguments and the action parameters.  Instead, we let the compiler infer the types for us. </P><P>Sometimes, however, we may want to be more explicit about the types. There are several tricks to do that.  For example: </P><PRE class="prettyprint"><SPAN class="pln">ACTION</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Makes sure arg0 can be converted to int.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> arg0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">use</SPAN><SPAN class="pln"> n instead of arg0 here </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR>ACTION_P</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">Bar</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> param</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// Makes sure the type of arg1 is const char*.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">StaticAssertTypeEq</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*,</SPAN><SPAN class="pln"> arg1_type</SPAN><SPAN class="pun">&gt;();</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Makes sure param can be converted to bool.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> flag </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> param</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>where <TT>StaticAssertTypeEq</TT> is a compile-time assertion in Google Test that verifies two types are the same. </P></A><H2><A name="Writing_New_Action_Templates_Quickly">Writing New Action Templates Quickly</A></H2><A name="Writing_New_Action_Templates_Quickly"><P>Sometimes you want to give an action explicit template parameters that cannot be inferred from its value parameters.  <TT>ACTION_TEMPLATE()</TT> supports that and can be viewed as an extension to <TT>ACTION()</TT> and <TT>ACTION_P*()</TT>. </P><P>The syntax: </P><PRE class="prettyprint"><SPAN class="pln">ACTION_TEMPLATE</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ActionName</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HAS_m_TEMPLATE_PARAMS</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">kind1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> name1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> kind_m</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> name_m</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AND_n_VALUE_PARAMS</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">p1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> p_n</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> statements</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">}</SPAN></PRE><P>defines an action template that takes <I>m</I> explicit template parameters and <I>n</I> value parameters, where <I>m</I> is between 1 and 10, and <I>n</I> is between 0 and 10.  <TT>name_i</TT> is the name of the i-th template parameter, and <TT>kind_i</TT> specifies whether it's a <TT>typename</TT>, an integral constant, or a template.  <TT>p_i</TT> is the name of the i-th value parameter. </P><P>Example: </P><PRE class="prettyprint"><SPAN class="com">// DuplicateArg&lt;k, T&gt;(output) converts the k-th argument of the mock</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="com">// function to type T and copies it to *output.</SPAN><SPAN class="pln"><BR>ACTION_TEMPLATE</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DuplicateArg</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// Note the comma between int and k:</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HAS_2_TEMPLATE_PARAMS</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> k</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> T</SPAN><SPAN class="pun">),</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AND_1_VALUE_PARAMS</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">output</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">output </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> T</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">tr1</SPAN><SPAN class="pun">::</SPAN><SPAN class="kwd">get</SPAN><SPAN class="str">&lt;k&gt;</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">args</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>To create an instance of an action template, write: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">ActionName</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">t1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> t_m</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">v1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> v_n</SPAN><SPAN class="pun">)</SPAN></PRE><P>where the <TT>t</TT>s are the template arguments and the <TT>v</TT>s are the value arguments.  The value argument types are inferred by the compiler.  For example: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">mock</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DuplicateArg</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">unsigned</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">&gt;(&amp;</SPAN><SPAN class="pln">n</SPAN><SPAN class="pun">));</SPAN></PRE><P>If you want to explicitly specify the value argument types, you can provide additional template arguments: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">ActionName</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="pln">t1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> t_m</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> u1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> u_k</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">v1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...,</SPAN><SPAN class="pln"> v_n</SPAN><SPAN class="pun">)</SPAN></PRE><P>where <TT>u_i</TT> is the desired type of <TT>v_i</TT>. </P><P><TT>ACTION_TEMPLATE</TT> and <TT>ACTION</TT>/<TT>ACTION_P*</TT> can be overloaded on the number of value parameters, but not on the number of template parameters.  Without the restriction, the meaning of the following is unclear: </P><PRE class="prettyprint"><SPAN class="pln">&nbsp; </SPAN><SPAN class="typ">OverloadedAction</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">x</SPAN><SPAN class="pun">);</SPAN></PRE><P>Are we using a single-template-parameter action where <TT>bool</TT> refers to the type of <TT>x</TT>, or a two-template-parameter action where the compiler is asked to infer the type of <TT>x</TT>? </P></A><H2><A name="Using_the_ACTION_Object&#39;s_Type">Using the ACTION Object's Type</A></H2><A name="Using_the_ACTION_Object&#39;s_Type"><P>If you are writing a function that returns an <TT>ACTION</TT> object, you'll need to know its type.  The type depends on the macro used to define the action and the parameter types.  The rule is relatively simple: </P><TABLE><TBODY><TR><TD style="border: 1px solid #aaa; padding: 5px;"> <STRONG>Given Definition</STRONG> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <STRONG>Expression</STRONG> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <STRONG>Has Type</STRONG> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>ACTION(Foo)</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>Foo()</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>FooAction</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>ACTION_TEMPLATE(Foo, HAS_m_TEMPLATE_PARAMS(...), AND_0_VALUE_PARAMS())</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;">	<TT>Foo&lt;t1, ..., t_m&gt;()</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>FooAction&lt;t1, ..., t_m&gt;</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>ACTION_P(Bar, param)</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>Bar(int_value)</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>BarActionP&lt;int&gt;</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>ACTION_TEMPLATE(Bar, HAS_m_TEMPLATE_PARAMS(...), AND_1_VALUE_PARAMS(p1))</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>Bar&lt;t1, ..., t_m&gt;(int_value)</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>FooActionP&lt;t1, ..., t_m, int&gt;</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>ACTION_P2(Baz, p1, p2)</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>Baz(bool_value, int_value)</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>BazActionP2&lt;bool, int&gt;</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>ACTION_TEMPLATE(Baz, HAS_m_TEMPLATE_PARAMS(...), AND_2_VALUE_PARAMS(p1, p2))</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>Baz&lt;t1, ..., t_m&gt;(bool_value, int_value)</TT> </TD><TD style="border: 1px solid #aaa; padding: 5px;"> <TT>FooActionP2&lt;t1, ..., t_m, bool, int&gt;</TT> </TD></TR> <TR><TD style="border: 1px solid #aaa; padding: 5px;"> ... </TD><TD style="border: 1px solid #aaa; padding: 5px;"> ... </TD><TD style="border: 1px solid #aaa; padding: 5px;"> ... </TD></TR> </TBODY></TABLE><P></P><P>Note that we have to pick different suffixes (<TT>Action</TT>, <TT>ActionP</TT>, <TT>ActionP2</TT>, and etc) for actions with different numbers of value parameters, or the action definitions cannot be overloaded on the number of them. </P></A><H2><A name="Writing_New_Monomorphic_Actions">Writing New Monomorphic Actions</A></H2><A name="Writing_New_Monomorphic_Actions"><P>While the <TT>ACTION*</TT> macros are very convenient, sometimes they are inappropriate.  For example, despite the tricks shown in the previous recipes, they don't let you directly specify the types of the mock function arguments and the action parameters, which in general leads to unoptimized compiler error messages that can baffle unfamiliar users.  They also don't allow overloading actions based on parameter types without jumping through some hoops. </P><P>An alternative to the <TT>ACTION*</TT> macros is to implement <TT>::testing::ActionInterface&lt;F&gt;</TT>, where <TT>F</TT> is the type of the mock function in which the action will be used. For example: </P><PRE class="prettyprint"><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> F</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ActionInterface</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">~</SPAN><SPAN class="typ">ActionInterface</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="com">// Performs the action. &nbsp;Result is the return type of function type</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// F, and ArgumentTuple is the tuple of arguments of F.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">//</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// For example, if F is int(bool, const string&amp;), then Result would</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="com">// be int, and ArgumentTuple would be tr1::tuple&lt;bool, const string&amp;&gt;.</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Result</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Perform</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ArgumentTuple</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> args</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">Action</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">ActionInterface</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MakeAction</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">typedef</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IncrementMethod</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*);</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IncrementArgumentAction</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ActionInterface</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">IncrementMethod</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">virtual</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Perform</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> tr1</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">tuple</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*&gt;&amp;</SPAN><SPAN class="pln"> args</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> p </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> tr1</SPAN><SPAN class="pun">::</SPAN><SPAN class="kwd">get</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">0</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">args</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Grabs the first argument.</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">p</SPAN><SPAN class="pun">++;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="typ">Action</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">IncrementMethod</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IncrementArgument</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MakeAction</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">new</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">IncrementArgumentAction</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Baz</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">IncrementArgument</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n </SPAN><SPAN class="pun">=</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">Baz</SPAN><SPAN class="pun">(&amp;</SPAN><SPAN class="pln">n</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Should return 5 and change n to 6.</SPAN></PRE></A><H2><A name="Writing_New_Polymorphic_Actions">Writing New Polymorphic Actions</A></H2><A name="Writing_New_Polymorphic_Actions"><P>The previous recipe showed you how to define your own action. This is all good, except that you need to know the type of the function in which the action will be used. Sometimes that can be a problem. For example, if you want to use the action in functions with <I>different</I> types (e.g. like <TT>Return()</TT> and <TT>SetArgumentPointee()</TT>). </P><P>If an action can be used in several types of mock functions, we say it's <I>polymorphic</I>. The <TT>MakePolymorphicAction()</TT> function template makes it easy to define such an action: </P><PRE class="prettyprint"><SPAN class="kwd">namespace</SPAN><SPAN class="pln"> testing </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Impl</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="typ">PolymorphicAction</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">Impl</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MakePolymorphicAction</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Impl</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> impl</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// namespace testing</SPAN></PRE><P>As an example, let's define an action that returns the second argument in the mock function's argument list. The first step is to define an implementation class: </P><PRE class="prettyprint"><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ReturnSecondArgumentAction</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">template</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Result</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">typename</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ArgumentTuple</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="typ">Result</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Perform</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ArgumentTuple</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> args</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="com">// To get the i-th (0-based) argument, use tr1::get&lt;i&gt;(args).</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> tr1</SPAN><SPAN class="pun">::</SPAN><SPAN class="kwd">get</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">&gt;(</SPAN><SPAN class="pln">args</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN></PRE><P>This implementation class does <I>not</I> need to inherit from any particular class. What matters is that it must have a <TT>Perform()</TT> method template. This method template takes the mock function's arguments as a tuple in a <STRONG>single</STRONG> argument, and returns the result of the action. It can be either <TT>const</TT> or not, but must be invokable with exactly one template argument, which is the result type. In other words, you must be able to call <TT>Perform&lt;R&gt;(args)</TT> where <TT>R</TT> is the mock function's return type and <TT>args</TT> is its arguments in a tuple. </P><P>Next, we use <TT>MakePolymorphicAction()</TT> to turn an instance of the implementation class into the polymorphic action we need. It will be convenient to have a wrapper for this: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">MakePolymorphicAction</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="typ">PolymorphicAction</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="typ">PolymorphicAction</SPAN><SPAN class="pun">&lt;</SPAN><SPAN class="typ">ReturnSecondArgumentAction</SPAN><SPAN class="pun">&gt;</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">ReturnSecondArgument</SPAN><SPAN class="pun">()</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MakePolymorphicAction</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnSecondArgumentAction</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN></PRE><P>Now, you can use this polymorphic action the same way you use the built-in ones: </P><PRE class="prettyprint"><SPAN class="kwd">using</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">testing</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">public</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp;</SPAN><SPAN class="kwd">public</SPAN><SPAN class="pun">:</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD2</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">bool</SPAN><SPAN class="pln"> flag</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> n</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR>&nbsp; MOCK_METHOD3</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">string</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">int</SPAN><SPAN class="pln"> x</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> str1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">char</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> str2</SPAN><SPAN class="pun">));</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR><BR>&nbsp; </SPAN><SPAN class="typ">MockFoo</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">;</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnSecondArgument</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; EXPECT_CALL</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="pln">_</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> _</SPAN><SPAN class="pun">))</SPAN><SPAN class="pln"><BR>&nbsp; &nbsp; &nbsp; </SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">WillOnce</SPAN><SPAN class="pun">(</SPAN><SPAN class="typ">ReturnSecondArgument</SPAN><SPAN class="pun">());</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThis</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">true</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="lit">5</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="com">// Will return 5.</SPAN><SPAN class="pln"><BR>&nbsp; foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DoThat</SPAN><SPAN class="pun">(</SPAN><SPAN class="lit">1</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"Hi"</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">"Bye"</SPAN><SPAN class="pun">);</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Will return "Hi".</SPAN></PRE></A><H2><A name="Teaching_Google_Mock_How_to_Print_Your_Values">Teaching Google Mock How to Print Your Values</A></H2><A name="Teaching_Google_Mock_How_to_Print_Your_Values"><P>When an uninteresting or unexpected call occurs, Google Mock prints the argument values to help you debug.  The <TT>EXPECT_THAT</TT> and <TT>ASSERT_THAT</TT> assertions also print the value being validated when the test fails.  Google Mock does this using the user-extensible value printer defined in <TT>&lt;gmock/gmock-printers.h&gt;</TT>. </P><P>This printer knows how to print the built-in C++ types, native arrays, STL containers, and any type that supports the <TT>&lt;&lt;</TT> operator. For other types, it prints the raw bytes in the value and hope you the user can figure it out. </P><P>Did I say that the printer is <TT>extensible</TT>? That means you can teach it to do a better job at printing your particular type than to dump the bytes. To do that, you just need to define <TT>&lt;&lt;</TT> for your type: </P><PRE class="prettyprint"><SPAN class="com">#include</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">&lt;iostream&gt;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">namespace</SPAN><SPAN class="pln"> foo </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="com">// It's important that the &lt;&lt; operator is defined in the SAME</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="com">// namespace that defines Foo. &nbsp;C++'s look-up rules rely on that.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">operator</SPAN><SPAN class="pun">&lt;&lt;(::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="kwd">return</SPAN><SPAN class="pln"> os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DebugString</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Whatever needed to print foo to os.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// namespace foo</SPAN></PRE><P>Sometimes, this might not be an option. For example, your team may consider it dangerous or bad style to have a <TT>&lt;&lt;</TT> operator for <TT>Foo</TT>, or <TT>Foo</TT> may already have a <TT>&lt;&lt;</TT> operator that doesn't do what you want (and you cannot change it). Don't despair though - Google Mock gives you a second chance to get it right. Namely, you can define a <TT>PrintTo()</TT> function like this: </P><PRE class="prettyprint"><SPAN class="com">#include</SPAN><SPAN class="pln"> </SPAN><SPAN class="str">&lt;iostream&gt;</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">namespace</SPAN><SPAN class="pln"> foo </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="kwd">class</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">...</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">};</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="com">// It's important that PrintTo() is defined in the SAME</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="com">// namespace that defines Foo. &nbsp;C++'s look-up rules rely on that.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="kwd">void</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">PrintTo</SPAN><SPAN class="pun">(</SPAN><SPAN class="kwd">const</SPAN><SPAN class="pln"> </SPAN><SPAN class="typ">Foo</SPAN><SPAN class="pun">&amp;</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">,</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">std</SPAN><SPAN class="pun">::</SPAN><SPAN class="pln">ostream</SPAN><SPAN class="pun">*</SPAN><SPAN class="pln"> os</SPAN><SPAN class="pun">)</SPAN><SPAN class="pln"> </SPAN><SPAN class="pun">{</SPAN><SPAN class="pln"><BR>&nbsp; </SPAN><SPAN class="pun">*</SPAN><SPAN class="pln">os </SPAN><SPAN class="pun">&lt;&lt;</SPAN><SPAN class="pln"> foo</SPAN><SPAN class="pun">.</SPAN><SPAN class="typ">DebugString</SPAN><SPAN class="pun">();</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// Whatever needed to print foo to os.</SPAN><SPAN class="pln"><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"><BR><BR></SPAN><SPAN class="pun">}</SPAN><SPAN class="pln"> &nbsp;</SPAN><SPAN class="com">// namespace foo</SPAN></PRE><P>What if you have both <TT>&lt;&lt;</TT> and <TT>PrintTo()</TT>? In this case, the latter will override the former when Google Mock is concerned. This allows you to customize how the value should appear in Google Mock's output without affecting code that relies on the behavior of its <TT>&lt;&lt;</TT> operator. </P><P><STRONG>Note:</STRONG> When printing a pointer of type <TT>T*</TT>, Google Mock calls <TT>PrintTo(T*, std::ostream* os)</TT> instead of <TT>operator&lt;&lt;(std::ostream&amp;, T*)</TT>. Therefore the only way to affect how a pointer is printed by Google Mock is to define <TT>PrintTo()</TT> for it. Also note that <TT>T*</TT> and <TT>const T*</TT> are different types, so you may need to define <TT>PrintTo()</TT> for both. </P><P>Why does Google Mock treat pointers specially? There are several reasons: </P><UL><LI>We cannot use <TT>operator&lt;&lt;</TT> to print a <TT>signed char*</TT> or <TT>unsigned char*</TT>, since it will print the pointer as a NUL-terminated C string, which likely will cause an access violation. </LI><LI>We want <TT>NULL</TT> pointers to be printed as <TT>"NULL"</TT>, but <TT>operator&lt;&lt;</TT> prints it as <TT>"0"</TT>, <TT>"nullptr"</TT>, or something else, depending on the compiler. </LI><LI>With some compilers, printing a <TT>NULL</TT> <TT>char*</TT> using <TT>operator&lt;&lt;</TT> will segfault. </LI><LI><TT>operator&lt;&lt;</TT> prints a function pointer as a <TT>bool</TT> (hence it always prints <TT>"1"</TT>), which is not very useful. </LI></UL>
 </A></TD> 
 </TR>
 </TBODY></TABLE>
 </DIV>


 
 
<FORM name="delcom" action="http://code.google.com/p/googlemock/w/delComment.do" method="POST">
 <INPUT type="hidden" name="sequence_num" value="">
 <INPUT type="hidden" name="mode" value="">
 <INPUT type="hidden" name="pagename" value="CookBook">
 <INPUT type="hidden" name="token" value="">
</FORM>



<SCRIPT src="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/prettify.js"></SCRIPT>
<SCRIPT type="text/javascript">
 prettyPrint();
</SCRIPT>
<SCRIPT type="text/javascript" src="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/dit_scripts_20081013.js"></SCRIPT>



  
 
 <SCRIPT type="text/javascript" src="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/core_scripts_20081103.js"></SCRIPT>
 <SCRIPT type="text/javascript" src="./CookBook - googlemock - Google C++ Mocking Framework Cookbook - Project Hosting on Google Code_files/codesite_product_dictionary_ph.pack.04102009.js"></SCRIPT>
 </DIV>
<DIV id="footer" dir="ltr">
 
 <DIV class="text">
 
 Â©2010 Google -
 <A href="http://code.google.com/projecthosting/terms.html">Terms</A> -
 <A href="http://www.google.com/privacy.html">Privacy</A> -
 <A href="http://code.google.com/p/support/">Project Hosting Help</A>
 
 </DIV>
</DIV>

 <DIV class="hostedBy" style="margin-top: -20px;">
 <SPAN style="vertical-align: top;">Powered by <A href="http://code.google.com/projecthosting/">Google Project Hosting</A></SPAN>
 </DIV>
 
 


 
 
 <SCRIPT type="text/javascript">_CS_reportToCsi();</SCRIPT>
 
 



<DIV class="menuDiv instance0" id="menuDiv-projects-dropdown" style="display: none; "><DIV class="menuCategory controls"><A class="menuItem" style="display: block; " href="http://www.google.com/accounts/ServiceLogin?service=code&ltmpl=phosting&continue=http%3A%2F%2Fcode.google.com%2Fp%2Fgooglemock%2Fwiki%2FCookBook&amp;followup=http%3A%2F%2Fcode.google.com%2Fp%2Fgooglemock%2Fwiki%2FCookBook">Sign in to see your favorites</A><HR class="menuSeparator"><A class="menuItem" style="display: block; " href="http://code.google.com/more/">Find developer products...</A><A class="menuItem" style="display: block; " href="http://code.google.com/hosting/">Find open source projects...</A></DIV></DIV></BODY></HTML>